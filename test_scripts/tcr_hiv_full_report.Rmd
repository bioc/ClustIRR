---
title: "HIV TCR Analysis Report"
author: "Kai Wollek"
date: "SS 2022"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: paper
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# set path to the working directory
require("knitr")
```

This markdown document is meant as documentation of the process and findings. <br> All scripts are called from here to create reproducible results.

# Session Initialization {.unnumbered}

```{r initialization, include=FALSE}
source("src/00_initializeSession/initializeSession.R")

# custom blue color
custom_blue = rgb(33, 150, 243, maxColorValue=255)

```

In this phase the working environment is prepared, handled by the script <a href="./src/00_initializeSession/initializeSession.R" target="_blank">initializeSession.R</a>. <br> Required libraries are imported, project environment, plots, and console get cleared, garbage collection is performed, and the number of CPU cores is detected.

# Data Import Check

```{r data_import, include=FALSE}
source("src/01_dataImportCheck/dataImportCheck.R")
```

The goal of this phase is to import the data set and the reference data set. After import, the data set contents are checked for specialties and anomalies as a basis for the successive [Data Transformation] phase. Script can be found here: <a href="./src/01_dataImportCheck/dataImportCheck.R" target="_blank">dataImportCheck.R</a>

## Data Sources

### Data Set Origin

-   The data was generated by Dr. Jun Wang and Dr. Li Qian, Southern University of Science and Technology, Shenzhen Third People's Hospital
-   Library generation was done using 10x Chromium solution (<https://www.10xgenomics.com/products/single-cell-immune-profiling>) and high throughput sequencing was performed on the Illumina platform
-   For each T-cell, we have a pair of TCRα and TCRβ chain sequences and corresponding annotations (V(D)J germline genes, CDR3 region sequences, etc.)
-   Peripheral blood mononuclear cells (PBMCs) were collected from all non-elite controllers (NECs) before antiretroviral therapy (ART)

### Data Set Contents

-   CDR3α/β region amino acid sequences
-   TRα/βV, TRα/βD, TRα/βJ, TRα/βC germline genes of TCRα/β
-   single cell gene expressions (scRNA) sequence data based on predicted cell types and prediction scores for a set of 8 general PBMC subtypes, further divided into a set of 31 specific PBMC subtypes

### Data Set Focus

-  Focus is set on CDR3β sequences / β genes and CD4 T and CD8 T cells because these regions are high-contact regions that play a major role in antigen detection
-  Future iterations could also investigate CDR3α sequences / α genes

## Observations

### Elite Controllers vs Non-Elite Controllers 
More different clones were found for Elite Controllers (EC) than for Non-Elite Controllers (NEC). Also, the absolute cell count for EC is higher. This could be a sign of depleted repertoires or measurement inaccuracies.

```{r di_condition_clones_and_count, echo=FALSE}
# Absolute Cell Count
a = as.data.frame(table(di$tcrs$condition))

a = a %>% dplyr::rename("Condition" = "Var1", "Clones"  = "Freq")

# Absolute Cell Count
b=aggregate(list(CellCount=di$tcrs$clone_members), list(Condition=di$tcrs$condition), sum)  

b=merge(a,b,by="Condition")

print(b, row.names=FALSE)

rm(a,b)


```


### Patients

- Clone members range from 1 to 114 per clone (Unique Molecular Identifiers (UMI)). The relatively sparse total samples count could lead to inconsistent results
- [Patient EC2+5] consists of two measurements of the same patient being tested twice within a short period (1 month or so). Decided to split EC2+5 into EC2 and EC5 for check of data, see [Data Splitting].
- [Patient EC4] has the lowest sample count, with most clones also being singletons, and therefore supposedly the highest possibility of inconsistent results


```{r di_subjects_barplot_clones_and_counts, echo=FALSE}
a = as.data.frame(table(di$tcrs$subject))

a = a %>% dplyr::rename("Patient" = "Var1", "Clones"  = "Freq")

b = aggregate(list(CellCount=di$tcrs$clone_members), list(Patient=di$tcrs$subject), sum)  

c = merge(a,b,by="Patient")

c = c %>% gather("Measurement", "Count", -Patient)

ggplot(c, aes(x=Patient, y=Count, fill=Measurement)) +
  geom_col(position = "dodge") +
  geom_text(aes(label=Count), color="white",position=position_dodge(width=0.9),vjust=1.5, size=3) +
  scale_fill_manual("",values = c("Clones" = custom_blue, "CellCount" = "gray70")) + 
  ylim(0, 4000)


rm(a,b,c)

```

### L1 Celltypes

The data set contains 8 different types of L1 cell types. Decided to split the data into CD4 T and CD8 T cells.

```{r di_celltype_l1, echo=FALSE}
table(di$tcrs$predicted.celltype.l1,di$tcrs$subject)
```

### L2 Celltypes

L1 cell types are further distinguished into 25 different types of L2 cell types. Decided to not split further until findings suggest otherwise.


```{r di_celltype_l2, echo=FALSE}
table(di$tcrs$predicted.celltype.l2, di$tcrs$predicted.celltype.l1)
```

# Data Transformation

```{r data_transform, include=FALSE}
source("src/02_dataTransformation/dataTransformation.R")
```

In the 
<a href="./src/02_dataTransformation/dataTransformation.R" target="_blank">dataTransformation.R</a> script the data is transformed based on the observations of the previous [Data Import Check] phase.

## Data Splitting

The data set is split by patient and L1 cell types.

### Split by Patient

```{r dt_subjects_barplot_clones_and_counts, echo=FALSE}
a = as.data.frame(table(dt$tcrs_transformed$patient))

a = a %>% dplyr::rename("Patient" = "Var1", "Clones"  = "Freq")

b = aggregate(list(CellCount=dt$tcrs_transformed$counts), list(Patient=dt$tcrs_transformed$patient), sum) 

c = merge(a,b,by="Patient")

c = c %>% gather("Measurement", "Count", -Patient)

ggplot(c, aes(x=Patient, y=Count, fill=Measurement)) +
  geom_col(position = "dodge") +
  geom_text(aes(label=Count), color="white",position=position_dodge(width=0.9),vjust=1.5, size=3) +
  scale_fill_manual("",values = c("Clones" = custom_blue, "CellCount" = "gray70")) + 
  ylim(0, 4000)


rm(a,b,c)

```

### Split by Cell Type

```{r dt_celltype_clones_and_counts, echo=FALSE}
# Distinct Clones for cell types
a = rbind(dt$tcrs_transformed_CD4T, dt$tcrs_transformed_CD8T)
a = as.data.frame(table(a$patient,a$l1ctype))
a = a %>% dplyr::rename("Patient" = "Var1", "Celltype" = "Var2",  "Clones"  = "Freq")

# Cell Counts
b = aggregate(list(cd4t=dt$tcrs_transformed_CD4T$counts), list(patient=dt$tcrs_transformed_CD4T$patient), sum)
c = aggregate(list(cd8t=dt$tcrs_transformed_CD8T$counts), list(patient=dt$tcrs_transformed_CD8T$patient), sum) 

c = merge(b,c, by="patient")
c = c %>% dplyr::rename("Patient" = "patient", "CD4 T" = "cd4t", "CD8 T" = "cd8t")

c = c %>% gather("Celltype", "CellCount", -Patient)

clones_and_cellcounts = cbind(a,list(CellCount = c$CellCount))

clones_and_cellcounts$RelativeCellCount = 
  clones_and_cellcounts$CellCount / clones_and_cellcounts$Clones * 100

ggplot(clones_and_cellcounts, aes(x=Patient, y=Clones, fill=Celltype)) +
  geom_col(position = "dodge") +
  geom_text(aes(label=Clones), color="white",position=position_dodge(width=0.9),vjust=1.5, size=3) +
  scale_fill_manual("",values = c("CD8 T" = custom_blue, "CD4 T" = "gray70")) + 
  ylim(0, 2000) +
  ggtitle("Clones Split by Celltype")


ggplot(c, aes(x=Patient, y=CellCount, fill=Celltype)) +
  geom_col(position = "dodge") +
  geom_text(aes(label=CellCount), color="white",position=position_dodge(width=0.9),vjust=1.5, size=3) +
  scale_fill_manual("",values = c("CD8 T" = custom_blue, "CD4 T" = "gray70")) + 
  ylim(0, 2000) + 
  ggtitle("Cell Count Split by Celltype")

rm(a,b,c)

```


# TCR Analysis

```{r tcr_analysis, include=FALSE}
source("src/03_TCRAnalysis/TCRAnalysis.R")
```

TurboGliph analysis of the transformed data set is performed inside the <a href="./src/03_TCRAnalysis/TCRAnalysis.R" target="_blank">TCRAnalysis.R</a> script. The simulation depth is set to 1250. For some reason using simulation depth bigger than 1500 leads to [Patient EC4] not being plottable later on. **-\> to be investigated**

## Reference Data Set Origin

-   Reference data set was downloaded from the GLIPH2 website <http://50.255.35.37:8080/>
-   Reference data for CD4 T, CD8 T, and combined CD4 T + CD8 T cells

# Results

```{r, include=FALSE}
source("src/04_resultVisualization/resultVisualization.R")
```

In the following sections, research questions and hypotheses are noted. <br> Findings are sorted by patient and cell type. <br>
Inside <a href="./src/04_resultVisualization/resultVisualization.R" target="_blank">resultVisualization.R</a> script network plots and de novo TCRs are computed for every patient and cell type.

## Research Questions

### Local Clustering
-   Are there (and which ones) motifs that are enriched in ECs but not in NECs and vice versa?
-   Are there motifs found in all patients?
-   As a proof-of-concept: do we see similar motif enrichment between EC2 and EC5?

### Network Output
-   Qualitative Analysis
    -   Do we see different network structures (degree of clustering) between patients or biological conditions?
-   Quantitative Analysis
    -   Do we see different network properties between patients or biological conditions?
    -   Can we integrate the network data with human CDR3b with known antigens from VDJdb?
        
## Hypotheses

### NEC CD4 T-Cell Depleation
HIV infects CD4+ T-cells. Do we see a "hole" in the CDR3b sequence space of TCR repertoires of NECs compared to ECs?

-   CD8 T-cells are HIV specific
-   CD4 T-cells could be depleted because of that
-   Also, CD4 T-cells can get lysed by HIV directly

Regarding the Non-Elite Controller's findings [Patient NEC1], [Patient NEC2], and [Patient NEC4] CD4 T-cell networks seem to be depleted in comparison to their CD8 T-cell networks. <br> 
Findings in Elite Controllers also imply that CD4 T-cells seem to not be depleted looking at [Patient EC1], [Patient EC2+5], and [Patient EC4]. Patient EC2+5 has a higher count of CD4 T-cells than of CD8 T-cells.
    
### NEC CD8 T-Cell HIV Specificity 
CD8+ T-cell response is mounted to kill infected CD4+ T-cells. This only happens in NECs (ECs somehow avoid chronic infection). Do we see more HIV-antigen-specific CDR3b sequences (e.g. based on VDJdb data) in CD8+ T-cells of NECs vs. ECs?

-   Check with VDJDB for specificities
-   For example, [Patient NEC1] CD8 vs CD4 may be a clue

### EC T-Cell HIV Specificity (to be discussed)
HIV specific CD8+ and CD4+ T-cells seem to be present in small cell counts in ECs and in larger cell counts in NECs. One possible explanation could be, that EC possess HIV specific T-cells as part of their immune repertoire. This could lead to an early and successful immune responses against HIV. NECs on the other hand could react to late, after HIV gained a critical mass (if this is a thing). <br>
Things to check:

-   EC vs NEC specificity & cell counts after BLOSUM62 categorization -> are counts really singleton vs enriched?
-   Related work / literature on EC HIV specificity

Other possible causes could be:

-   Programming error (double check)
-   Measurement errors at data collection (rule out with other data set?)
-   False positive specificity of VDJDB, MCPAS, TBADB (maybe more db?)
-   EC patients are not really "EC" (compare with different data?)
-   HIV specific CD8+ and CD4+ T-cells in EC are unique to EC (check for occurence in NEC)

## HIV Specificity

VDJdb check with online mask showed some HIV-1, SARS-CoV-2, CMV, InfluenzaA, etc. Filtered the databases for HIV pathogen for now.

With a Damerau-Levenshtein distance of 0, the following about perfect matches was found:

-   Found unexpected CD4T specificities in [Patient EC2+5] and [Patient EC4], that are marked as CD8T in VDJdb (possible measurement error)
-   Found unexpected CD8T specificities in [Patient EC1] and [Patient EC2+5]
-   Found no CD4T specificities in any NEC Patient
-   Found CD8T specificities in [Patient NEC1] and [Patient NEC4]
-   CDR3b (CASSETGGTYEQYF) and CDR3a (CVVNSGAGSYQLTF) pair found in [Patient NEC1] and [Patient NEC4]


With Damerau-Levenshtein distance <= 1, matches for both CD4T and CD8T were found in all patients. To ensure the found 

### Specificity Data Sets

-   VDJdb was downloaded from the vdjdb website <https://vdjdb.cdr3.net/>
-   McPAS-TCR was downloaded from <http://friedmanlab.weizmann.ac.il/McPAS-TCR/>
-   TBAdb (see <https://doi.org/10.1093/bioinformatics/btz614>) was downloaded via <https://gitlab.com/immunomind/immunarch/raw/dev-0.5.0/private/TBAdb.xlsx>
-   Databases were imported and filtered using the immunarch package <https://immunarch.com>

### Annotation with VDJdb

11 perfect matches (Damerau-Levenshtein distance of 0)

```{r vdjdb_specificity, echo=FALSE}
# VDJDB
specificity_vdjdb = dbAnnotate(dt$ia_list, di$vdjdb, "CDR3.aa", "cdr3")
specificity_vdjdb
```

297 matches with Damerau-Levenshtein distances of 0 and 1

```{r vdjdb_levenshtein, echo=FALSE}

ec1cd4t = as.data.frame(dt$specificity_vdjdb_dl1$ia_EC1_CD4T)
ec1cd4t = ec1cd4t %>% group_by(CDR3.aa) %>% summarise(EC1_CD4T_Matches = n_distinct(cdr3))
ec1cd4t_counts = dt$EC1_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC1_CD4T = sum(counts))
ec1cd4t = merge(ec1cd4t, ec1cd4t_counts)

ec1cd8t = as.data.frame(dt$specificity_vdjdb_dl1$ia_EC1_CD8T)
ec1cd8t = ec1cd8t %>% group_by(CDR3.aa) %>% summarise(EC1_CD8T_Matches = n_distinct(cdr3))
ec1cd8t_counts = dt$EC1_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC1_CD8T = sum(counts))
ec1cd8t = merge(ec1cd8t, ec1cd8t_counts)

ec2_5cd4t = as.data.frame(dt$specificity_vdjdb_dl1$ia_EC2_5_CD4T)
ec2_5cd4t = ec2_5cd4t %>% group_by(CDR3.aa) %>% summarise(EC2_5_CD4T_Matches = n_distinct(cdr3))
ec2_5cd4t_counts = dt$EC2_5_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC2_5_CD4T = sum(counts))
ec2_5cd4t = merge(ec2_5cd4t, ec2_5cd4t_counts)

ec2_5cd8t = as.data.frame(dt$specificity_vdjdb_dl1$ia_EC2_5_CD8T)
ec2_5cd8t = ec2_5cd8t %>% group_by(CDR3.aa) %>% summarise(EC2_5_CD8T_Matches = n_distinct(cdr3))
ec2_5cd8t_counts = dt$EC2_5_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC2_5_CD8T = sum(counts))
ec2_5cd8t = merge(ec2_5cd8t, ec2_5cd8t_counts)


ec4cd4t = as.data.frame(dt$specificity_vdjdb_dl1$ia_EC4_CD4T)
ec4cd4t = ec4cd4t %>% group_by(CDR3.aa) %>% summarise(EC4_CD4T_Matches = n_distinct(cdr3))
ec4cd4t_counts = dt$EC4_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC4_CD4T = sum(counts))
ec4cd4t = merge(ec4cd4t, ec4cd4t_counts)

ec4cd8t = as.data.frame(dt$specificity_vdjdb_dl1$ia_EC4_CD8T)
ec4cd8t = ec4cd8t %>% group_by(CDR3.aa) %>% summarise(EC4_CD8T_Matches = n_distinct(cdr3))
ec4cd8t_counts = dt$EC4_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC4_CD8T = sum(counts))
ec4cd8t = merge(ec4cd8t, ec4cd8t_counts)


nec1cd4t = as.data.frame(dt$specificity_vdjdb_dl1$ia_NEC1_CD4T)
nec1cd4t = nec1cd4t %>% group_by(CDR3.aa) %>% summarise(NEC1_CD4T_Matches = n_distinct(cdr3))
nec1cd4t_counts = dt$NEC1_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC1_CD4T = sum(counts))
nec1cd4t = merge(nec1cd4t, nec1cd4t_counts)

nec1cd8t = as.data.frame(dt$specificity_vdjdb_dl1$ia_NEC1_CD8T)
nec1cd8t = nec1cd8t %>% group_by(CDR3.aa) %>% summarise(NEC1_CD8T_Matches = n_distinct(cdr3))
nec1cd8t_counts = dt$NEC1_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC1_CD8T = sum(counts))
nec1cd8t = merge(nec1cd8t, nec1cd8t_counts)


nec2cd4t = as.data.frame(dt$specificity_vdjdb_dl1$ia_NEC2_CD4T)
nec2cd4t = nec2cd4t %>% group_by(CDR3.aa) %>% summarise(NEC2_CD4T_Matches = n_distinct(cdr3))
nec2cd4t_counts = dt$NEC2_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC2_CD4T = sum(counts))
nec2cd4t = merge(nec2cd4t, nec2cd4t_counts)

nec2cd8t = as.data.frame(dt$specificity_vdjdb_dl1$ia_NEC2_CD8T)
nec2cd8t = nec2cd8t %>% group_by(CDR3.aa) %>% summarise(NEC2_CD8T_Matches = n_distinct(cdr3))
nec2cd8t_counts = dt$NEC2_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC2_CD8T = sum(counts))
nec2cd8t = merge(nec2cd8t, nec2cd8t_counts)


nec4cd4t = as.data.frame(dt$specificity_vdjdb_dl1$ia_NEC4_CD4T)
nec4cd4t = nec4cd4t %>% group_by(CDR3.aa) %>% summarise(NEC4_CD4T_Matches = n_distinct(cdr3))
nec4cd4t_counts = dt$NEC4_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC4_CD4T = sum(counts))
nec4cd4t = merge(nec4cd4t, nec4cd4t_counts)

nec4cd8t = as.data.frame(dt$specificity_vdjdb_dl1$ia_NEC4_CD8T)
nec4cd8t = nec4cd8t %>% group_by(CDR3.aa) %>% summarise(NEC4_CD8T_Matches = n_distinct(cdr3))
nec4cd8t_counts = dt$NEC4_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC4_CD8T = sum(counts))
nec4cd8t = merge(nec4cd8t, nec4cd8t_counts)


patient_list = list(ec1cd4t, ec1cd8t, ec2_5cd4t, ec2_5cd8t, ec4cd4t, ec4cd8t, 
          nec1cd4t, nec1cd8t, nec2cd4t, nec2cd8t, nec4cd4t, nec4cd8t)
m = Reduce(function(x, y) merge(x, y, by = 'CDR3.aa', all=TRUE), patient_list)
m[is.na(m)] = 0


m$Samples = m$EC1_CD4T + m$EC1_CD8T + m$EC2_5_CD4T + m$EC2_5_CD8T + m$EC4_CD4T + m$EC4_CD8T +
            m$NEC1_CD4T + m$NEC1_CD8T + m$NEC2_CD4T + m$NEC2_CD8T + m$NEC4_CD4T + m$NEC4_CD8T

m = m[order(-m$Samples),]

specificity_vdjdb_dl1  = m[, c('CDR3.aa', 'Samples', 
                               'EC1_CD4T', 'EC1_CD8T', 'EC2_5_CD4T', 'EC2_5_CD8T', 'EC4_CD4T', 'EC4_CD8T', 
                               'NEC1_CD4T', 'NEC1_CD8T', 'NEC2_CD4T', 'NEC2_CD8T', 'NEC4_CD4T', 'NEC4_CD8T')]

print(specificity_vdjdb_dl1, row.names = FALSE)

rm(ec1cd4t,  ec1cd8t,  ec2_5cd4t, ec2_5cd8t, ec4cd4t,  ec4cd8t, 
   nec1cd4t, nec1cd8t, nec2cd4t,  nec2cd8t,  nec4cd4t, nec4cd8t, 
   ec1cd4t_counts, ec1cd8t_counts, ec2_5cd4t_counts, ec2_5cd8t_counts, ec4cd4t_counts, ec4cd8t_counts,
   nec1cd4t_counts, nec1cd8t_counts, nec2cd4t_counts, nec2cd8t_counts, nec4cd4t_counts, nec4cd8t_counts,
   patient_list, m)

```

### Annotation with McPAS-TCR

2 perfect matches (Damerau-Levenshtein distance of 0)

```{r mcpas_specificity, echo=FALSE}
# McPAS-TCR
specificity_mcpas = dbAnnotate(dt$ia_list, di$mcpas, "CDR3.aa", "CDR3.beta.aa")
specificity_mcpas
```
65 matches with Damerau-Levenshtein distances of 0 and 1

```{r mcpas_levenshtein, echo=FALSE}

ec1cd4t = as.data.frame(dt$specificity_mcpas_dl1$ia_EC1_CD4T)
ec1cd4t = ec1cd4t %>% group_by(CDR3.aa) %>% summarise(EC1_CD4T_Matches = n_distinct(CDR3.beta.aa))
ec1cd4t_counts = dt$EC1_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC1_CD4T = sum(counts))
ec1cd4t = merge(ec1cd4t, ec1cd4t_counts)

ec1cd8t = as.data.frame(dt$specificity_mcpas_dl1$ia_EC1_CD8T)
ec1cd8t = ec1cd8t %>% group_by(CDR3.aa) %>% summarise(EC1_CD8T_Matches = n_distinct(CDR3.beta.aa))
ec1cd8t_counts = dt$EC1_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC1_CD8T = sum(counts))
ec1cd8t = merge(ec1cd8t, ec1cd8t_counts)

ec2_5cd4t = as.data.frame(dt$specificity_mcpas_dl1$ia_EC2_5_CD4T)
ec2_5cd4t = ec2_5cd4t %>% group_by(CDR3.aa) %>% summarise(EC2_5_CD4T_Matches = n_distinct(CDR3.beta.aa))
ec2_5cd4t_counts = dt$EC2_5_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC2_5_CD4T = sum(counts))
ec2_5cd4t = merge(ec2_5cd4t, ec2_5cd4t_counts)

ec2_5cd8t = as.data.frame(dt$specificity_mcpas_dl1$ia_EC2_5_CD8T)
ec2_5cd8t = ec2_5cd8t %>% group_by(CDR3.aa) %>% summarise(EC2_5_CD8T_Matches = n_distinct(CDR3.beta.aa))
ec2_5cd8t_counts = dt$EC2_5_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC2_5_CD8T = sum(counts))
ec2_5cd8t = merge(ec2_5cd8t, ec2_5cd8t_counts)


ec4cd4t = as.data.frame(dt$specificity_mcpas_dl1$ia_EC4_CD4T)
ec4cd4t = ec4cd4t %>% group_by(CDR3.aa) %>% summarise(EC4_CD4T_Matches = n_distinct(CDR3.beta.aa))
ec4cd4t_counts = dt$EC4_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC4_CD4T = sum(counts))
ec4cd4t = merge(ec4cd4t, ec4cd4t_counts)

ec4cd8t = as.data.frame(dt$specificity_mcpas_dl1$ia_EC4_CD8T)
ec4cd8t = ec4cd8t %>% group_by(CDR3.aa) %>% summarise(EC4_CD8T_Matches = n_distinct(CDR3.beta.aa))
ec4cd8t_counts = dt$EC4_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC4_CD8T = sum(counts))
ec4cd8t = merge(ec4cd8t, ec4cd8t_counts)


nec1cd4t = as.data.frame(dt$specificity_mcpas_dl1$ia_NEC1_CD4T)
nec1cd4t = nec1cd4t %>% group_by(CDR3.aa) %>% summarise(NEC1_CD4T_Matches = n_distinct(CDR3.beta.aa))
nec1cd4t_counts = dt$NEC1_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC1_CD4T = sum(counts))
nec1cd4t = merge(nec1cd4t, nec1cd4t_counts)

nec1cd8t = as.data.frame(dt$specificity_mcpas_dl1$ia_NEC1_CD8T)
nec1cd8t = nec1cd8t %>% group_by(CDR3.aa) %>% summarise(NEC1_CD8T_Matches = n_distinct(CDR3.beta.aa))
nec1cd8t_counts = dt$NEC1_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC1_CD8T = sum(counts))
nec1cd8t = merge(nec1cd8t, nec1cd8t_counts)


nec2cd4t = as.data.frame(dt$specificity_mcpas_dl1$ia_NEC2_CD4T)
nec2cd4t = nec2cd4t %>% group_by(CDR3.aa) %>% summarise(NEC2_CD4T_Matches = n_distinct(CDR3.beta.aa))
nec2cd4t_counts = dt$NEC2_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC2_CD4T = sum(counts))
nec2cd4t = merge(nec2cd4t, nec2cd4t_counts)

nec2cd8t = as.data.frame(dt$specificity_mcpas_dl1$ia_NEC2_CD8T)
nec2cd8t = nec2cd8t %>% group_by(CDR3.aa) %>% summarise(NEC2_CD8T_Matches = n_distinct(CDR3.beta.aa))
nec2cd8t_counts = dt$NEC2_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC2_CD8T = sum(counts))
nec2cd8t = merge(nec2cd8t, nec2cd8t_counts)


nec4cd4t = as.data.frame(dt$specificity_mcpas_dl1$ia_NEC4_CD4T)
nec4cd4t = nec4cd4t %>% group_by(CDR3.aa) %>% summarise(NEC4_CD4T_Matches = n_distinct(CDR3.beta.aa))
nec4cd4t_counts = dt$NEC4_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC4_CD4T = sum(counts))
nec4cd4t = merge(nec4cd4t, nec4cd4t_counts)

nec4cd8t = as.data.frame(dt$specificity_mcpas_dl1$ia_NEC4_CD8T)
nec4cd8t = nec4cd8t %>% group_by(CDR3.aa) %>% summarise(NEC4_CD8T_Matches = n_distinct(CDR3.beta.aa))
nec4cd8t_counts = dt$NEC4_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC4_CD8T = sum(counts))
nec4cd8t = merge(nec4cd8t, nec4cd8t_counts)


patient_list = list(ec1cd4t, ec1cd8t, ec2_5cd4t, ec2_5cd8t, ec4cd4t, ec4cd8t, 
          nec1cd4t, nec1cd8t, nec2cd4t, nec2cd8t, nec4cd4t, nec4cd8t)
m = Reduce(function(x, y) merge(x, y, by = 'CDR3.aa', all=TRUE), patient_list)
m[is.na(m)] = 0


m$Samples = m$EC1_CD4T + m$EC1_CD8T + m$EC2_5_CD4T + m$EC2_5_CD8T + m$EC4_CD4T + m$EC4_CD8T +
            m$NEC1_CD4T + m$NEC1_CD8T + m$NEC2_CD4T + m$NEC2_CD8T + m$NEC4_CD4T + m$NEC4_CD8T

m = m[order(-m$Samples),]

specificity_mcpas_dl1  = m[, c('CDR3.aa', 'Samples', 
                               'EC1_CD4T', 'EC1_CD8T', 'EC2_5_CD4T', 'EC2_5_CD8T', 'EC4_CD4T', 'EC4_CD8T', 
                               'NEC1_CD4T', 'NEC1_CD8T', 'NEC2_CD4T', 'NEC2_CD8T', 'NEC4_CD4T', 'NEC4_CD8T')]

print(specificity_mcpas_dl1, row.names = FALSE)

rm(ec1cd4t,  ec1cd8t,  ec2_5cd4t, ec2_5cd8t, ec4cd4t,  ec4cd8t, 
   nec1cd4t, nec1cd8t, nec2cd4t,  nec2cd8t,  nec4cd4t, nec4cd8t, 
   ec1cd4t_counts, ec1cd8t_counts, ec2_5cd4t_counts, ec2_5cd8t_counts, ec4cd4t_counts, ec4cd8t_counts,
   nec1cd4t_counts, nec1cd8t_counts, nec2cd4t_counts, nec2cd8t_counts, nec4cd4t_counts, nec4cd8t_counts,
   patient_list, m)

```


### Annotation with TBAdb

3 perfect matches (Damerau-Levenshtein distance of 0)

```{r tbadb_specificity, echo=FALSE}
# TBAdb from PIRD
specificity_tbadb = dbAnnotate(dt$ia_list, di$tbadb, "CDR3.aa", "CDR3.beta.aa")
specificity_tbadb
```

77 matches with Damerau-Levenshtein distances of 0 and 1

```{r tbadb_levenshtein, echo=FALSE}

ec1cd4t = as.data.frame(dt$specificity_tbadb_dl1$ia_EC1_CD4T)
ec1cd4t = ec1cd4t %>% group_by(CDR3.aa) %>% summarise(EC1_CD4T_Matches = n_distinct(CDR3.beta.aa))
ec1cd4t_counts = dt$EC1_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC1_CD4T = sum(counts))
ec1cd4t = merge(ec1cd4t, ec1cd4t_counts)

ec1cd8t = as.data.frame(dt$specificity_tbadb_dl1$ia_EC1_CD8T)
ec1cd8t = ec1cd8t %>% group_by(CDR3.aa) %>% summarise(EC1_CD8T_Matches = n_distinct(CDR3.beta.aa))
ec1cd8t_counts = dt$EC1_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC1_CD8T = sum(counts))
ec1cd8t = merge(ec1cd8t, ec1cd8t_counts)

ec2_5cd4t = as.data.frame(dt$specificity_tbadb_dl1$ia_EC2_5_CD4T)
ec2_5cd4t = ec2_5cd4t %>% group_by(CDR3.aa) %>% summarise(EC2_5_CD4T_Matches = n_distinct(CDR3.beta.aa))
ec2_5cd4t_counts = dt$EC2_5_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC2_5_CD4T = sum(counts))
ec2_5cd4t = merge(ec2_5cd4t, ec2_5cd4t_counts)

ec2_5cd8t = as.data.frame(dt$specificity_tbadb_dl1$ia_EC2_5_CD8T)
ec2_5cd8t = ec2_5cd8t %>% group_by(CDR3.aa) %>% summarise(EC2_5_CD8T_Matches = n_distinct(CDR3.beta.aa))
ec2_5cd8t_counts = dt$EC2_5_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC2_5_CD8T = sum(counts))
ec2_5cd8t = merge(ec2_5cd8t, ec2_5cd8t_counts)


ec4cd4t = as.data.frame(dt$specificity_tbadb_dl1$ia_EC4_CD4T)
ec4cd4t = ec4cd4t %>% group_by(CDR3.aa) %>% summarise(EC4_CD4T_Matches = n_distinct(CDR3.beta.aa))
ec4cd4t_counts = dt$EC4_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC4_CD4T = sum(counts))
ec4cd4t = merge(ec4cd4t, ec4cd4t_counts)

ec4cd8t = as.data.frame(dt$specificity_tbadb_dl1$ia_EC4_CD8T)
ec4cd8t = ec4cd8t %>% group_by(CDR3.aa) %>% summarise(EC4_CD8T_Matches = n_distinct(CDR3.beta.aa))
ec4cd8t_counts = dt$EC4_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(EC4_CD8T = sum(counts))
ec4cd8t = merge(ec4cd8t, ec4cd8t_counts)


nec1cd4t = as.data.frame(dt$specificity_tbadb_dl1$ia_NEC1_CD4T)
nec1cd4t = nec1cd4t %>% group_by(CDR3.aa) %>% summarise(NEC1_CD4T_Matches = n_distinct(CDR3.beta.aa))
nec1cd4t_counts = dt$NEC1_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC1_CD4T = sum(counts))
nec1cd4t = merge(nec1cd4t, nec1cd4t_counts)

nec1cd8t = as.data.frame(dt$specificity_tbadb_dl1$ia_NEC1_CD8T)
nec1cd8t = nec1cd8t %>% group_by(CDR3.aa) %>% summarise(NEC1_CD8T_Matches = n_distinct(CDR3.beta.aa))
nec1cd8t_counts = dt$NEC1_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC1_CD8T = sum(counts))
nec1cd8t = merge(nec1cd8t, nec1cd8t_counts)


nec2cd4t = as.data.frame(dt$specificity_tbadb_dl1$ia_NEC2_CD4T)
nec2cd4t = nec2cd4t %>% group_by(CDR3.aa) %>% summarise(NEC2_CD4T_Matches = n_distinct(CDR3.beta.aa))
nec2cd4t_counts = dt$NEC2_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC2_CD4T = sum(counts))
nec2cd4t = merge(nec2cd4t, nec2cd4t_counts)

nec2cd8t = as.data.frame(dt$specificity_tbadb_dl1$ia_NEC2_CD8T)
nec2cd8t = nec2cd8t %>% group_by(CDR3.aa) %>% summarise(NEC2_CD8T_Matches = n_distinct(CDR3.beta.aa))
nec2cd8t_counts = dt$NEC2_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC2_CD8T = sum(counts))
nec2cd8t = merge(nec2cd8t, nec2cd8t_counts)


nec4cd4t = as.data.frame(dt$specificity_tbadb_dl1$ia_NEC4_CD4T)
nec4cd4t = nec4cd4t %>% group_by(CDR3.aa) %>% summarise(NEC4_CD4T_Matches = n_distinct(CDR3.beta.aa))
nec4cd4t_counts = dt$NEC4_CD4T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC4_CD4T = sum(counts))
nec4cd4t = merge(nec4cd4t, nec4cd4t_counts)

nec4cd8t = as.data.frame(dt$specificity_tbadb_dl1$ia_NEC4_CD8T)
nec4cd8t = nec4cd8t %>% group_by(CDR3.aa) %>% summarise(NEC4_CD8T_Matches = n_distinct(CDR3.beta.aa))
nec4cd8t_counts = dt$NEC4_CD8T %>% group_by(CDR3.aa = CDR3b) %>% summarise(NEC4_CD8T = sum(counts))
nec4cd8t = merge(nec4cd8t, nec4cd8t_counts)


patient_list = list(ec1cd4t, ec1cd8t, ec2_5cd4t, ec2_5cd8t, ec4cd4t, ec4cd8t, 
          nec1cd4t, nec1cd8t, nec2cd4t, nec2cd8t, nec4cd4t, nec4cd8t)
m = Reduce(function(x, y) merge(x, y, by = 'CDR3.aa', all=TRUE), patient_list)
m[is.na(m)] = 0


m$Samples = m$EC1_CD4T + m$EC1_CD8T + m$EC2_5_CD4T + m$EC2_5_CD8T + m$EC4_CD4T + m$EC4_CD8T +
            m$NEC1_CD4T + m$NEC1_CD8T + m$NEC2_CD4T + m$NEC2_CD8T + m$NEC4_CD4T + m$NEC4_CD8T

m = m[order(-m$Samples),]

specificity_tbadb_dl1  = m[, c('CDR3.aa', 'Samples', 
                               'EC1_CD4T', 'EC1_CD8T', 'EC2_5_CD4T', 'EC2_5_CD8T', 'EC4_CD4T', 'EC4_CD8T', 
                               'NEC1_CD4T', 'NEC1_CD8T', 'NEC2_CD4T', 'NEC2_CD8T', 'NEC4_CD4T', 'NEC4_CD8T')]

print(specificity_tbadb_dl1, row.names = FALSE)

rm(ec1cd4t,  ec1cd8t,  ec2_5cd4t, ec2_5cd8t, ec4cd4t,  ec4cd8t, 
   nec1cd4t, nec1cd8t, nec2cd4t,  nec2cd8t,  nec4cd4t, nec4cd8t, 
   ec1cd4t_counts, ec1cd8t_counts, ec2_5cd4t_counts, ec2_5cd8t_counts, ec4cd4t_counts, ec4cd8t_counts,
   nec1cd4t_counts, nec1cd8t_counts, nec2cd4t_counts, nec2cd8t_counts, nec4cd4t_counts, nec4cd8t_counts,
   patient_list, m)


```

### Absolute & Relative Matches

The absolute and relative frequency of perfect matches shows no cell count bias, higher absolute counts seem to correlate with higher relative values.

```{r relative_matches, echo=FALSE}

a = subset_specificity('ia_EC1_CD4T','ia_EC1_CD8T')
a$Patient = "EC1"
a$CD4T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "EC1",
                           Celltype == "CD4 T")$CellCount 
a$CD8T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "EC1",
                           Celltype == "CD8 T")$CellCount 

b = subset_specificity('ia_EC2_5_CD4T','ia_EC2_5_CD8T')
b$Patient = "EC2_5"
b$CD4T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "EC2+5",
                           Celltype == "CD4 T")$CellCount 
b$CD8T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "EC2+5",
                           Celltype == "CD8 T")$CellCount 


c = subset_specificity('ia_EC4_CD4T','ia_EC4_CD8T')
c$Patient = "EC4"
c$CD4T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "EC4",
                           Celltype == "CD4 T")$CellCount 
c$CD8T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "EC4",
                           Celltype == "CD8 T")$CellCount 

d = subset_specificity('ia_NEC1_CD4T','ia_NEC1_CD8T')
d$Patient = "NEC1"
d$CD4T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "NEC1",
                           Celltype == "CD4 T")$CellCount 
d$CD8T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "NEC1",
                           Celltype == "CD8 T")$CellCount 

# no specificity for NEC2 found
#e = subset_specificity('ia_NEC2_CD4T','ia_NEC2_CD8T')
#e$patient = "NEC2"

f = subset_specificity('ia_NEC4_CD4T','ia_NEC4_CD8T')
f$Patient = "NEC4"
f$CD4T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "NEC4",
                           Celltype == "CD4 T")$CellCount 
f$CD8T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "NEC4",
                           Celltype == "CD8 T")$CellCount

g = rbind(a,b,c,d,f)

g$CD4T_Relative = g$CD4T / g$CD4T_CellCount
g$CD8T_Relative = g$CD8T / g$CD8T_CellCount

g = as.data.frame(select(g, c('Patient', 'CDR3b', 'CD4T', 'CD4T_Relative','CD8T', 'CD8T_Relative')))

print(g, row.names = FALSE)

rm(a,b,c,d,f,g)

```
The absolute and relative frequency of matches with Damerau-Levenshtein distance <= 1 shows no cell count bias, higher absolute counts seem to correlate with higher relative values.

```{r relative_matches_dl1, echo=FALSE}

a = subset_specificity_dl1('EC1_CD4T','EC1_CD8T')
a$Patient = "EC1"
a$CD4T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "EC1",
                           Celltype == "CD4 T")$CellCount 
a$CD8T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "EC1",
                           Celltype == "CD8 T")$CellCount 

b = subset_specificity_dl1('EC2_5_CD4T','EC2_5_CD8T')
b$Patient = "EC2_5"
b$CD4T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "EC2+5",
                           Celltype == "CD4 T")$CellCount 
b$CD8T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "EC2+5",
                           Celltype == "CD8 T")$CellCount 


c = subset_specificity_dl1('EC4_CD4T','EC4_CD8T')
c$Patient = "EC4"
c$CD4T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "EC4",
                           Celltype == "CD4 T")$CellCount 
c$CD8T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "EC4",
                           Celltype == "CD8 T")$CellCount 

d = subset_specificity_dl1('NEC1_CD4T','NEC1_CD8T')
d$Patient = "NEC1"
d$CD4T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "NEC1",
                           Celltype == "CD4 T")$CellCount 
d$CD8T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "NEC1",
                           Celltype == "CD8 T")$CellCount 

# no specificity for NEC2 found
#e = subset_specificity_dl1('NEC2_CD4T','NEC2_CD8T')
#e$patient = "NEC2"

f = subset_specificity_dl1('NEC4_CD4T','NEC4_CD8T')
f$Patient = "NEC4"
f$CD4T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "NEC4",
                           Celltype == "CD4 T")$CellCount 
f$CD8T_CellCount = filter(clones_and_cellcounts, 
                           Patient == "NEC4",
                           Celltype == "CD8 T")$CellCount

g = rbind(a,b,c,d,f)

g$CD4T_Relative = g$CD4T / g$CD4T_CellCount
g$CD8T_Relative = g$CD8T / g$CD8T_CellCount

g = as.data.frame(select(g, c('Patient', 'CDR3b', 'CD4T', 'CD4T_Relative','CD8T', 'CD8T_Relative')))

print(g, row.names = FALSE)

rm(a,b,c,d,f,g)

```

### Check for enrichment of HIV-specific CDR3s in NECs

We see clonal expansion of CD8+ T-cells in NECs. 

Followup questions:
  
  * do TCR repertoires of NECs contain HIV-specific CDR3s? 
  * are TCR repertoires of NECs **enriched** with HIV-specific CDR3s compared 
  to ECs?
  * Puzzle 1: how do we detect HIV-specific CDR3s? Identical matches in VDJdb, 
  similar matches? 
  * Puzzle 2: what is the probability of generating these HIV-specific CDR3s 
  `by chance ($P_{gen}$?)

```{r}
# identity match
# added VDJdb and McPAS with Damerau-Levenshtein distance <=1
dt$tcrs_transformed$match_hiv = ifelse(test = dt$tcrs_transformed$CDR3b %in% 
                                       c(specificity_vdjdb_dl1$CDR3.aa, 
                                         specificity_mcpas_dl1$CDR3.aa,
                                         specificity_tbadb_dl1$CDR3.aa),
                                yes = 1, no = 0)
```

```{r}
# add distance 1
dt$tcrs_transformed$dl_dist = ifelse(test = dt$tcrs_transformed$CDR3b %in% 
                                       c(specificity_vdjdb_dl1$CDR3.aa, 
                                         specificity_mcpas_dl1$CDR3.aa,
                                         specificity_tbadb_dl1$CDR3.aa),
                                yes = 1, no = NA)
# add distance 0 (perfect matches)
dt$tcrs_transformed$dl_dist = ifelse(test = dt$tcrs_transformed$CDR3b %in% 
                                       c(specificity_vdjdb$CDR3.aa, 
                                         specificity_mcpas$CDR3.aa,
                                         specificity_tbadb$CDR3.aa),
                                yes = 0, no = dt$tcrs_transformed$dl_dist)

```

```{r}
# raw data
kable(dt$tcrs_transformed[dt$tcrs_transformed$match_hiv==1, c("CDR3b", "patient", "condition", 
                                "TRBV", "TRBJ", 
                                "l1ctype", 
                                "l1score", 
                                "counts",
                                "p_gen",
                                "BLOSUM62_score",
                                "BLOSUM62_pattern",
                                "dl_dist")])
```


```{r}
# summary of the number of HIV-specific clones
summary_hiv_clones <- aggregate(match_hiv~patient+condition+l1ctype, 
                                data = dt$tcrs_transformed,
                                FUN = sum)

# filtered by actual matches
kable(summary_hiv_clones[summary_hiv_clones$match_hiv>=1,])
```


```{r}
# summary of the number of HIV-specific cells
summary_hiv_cells <- aggregate(counts~patient+condition+l1ctype, 
                               data = dt$tcrs_transformed[dt$tcrs_transformed$match_hiv==1,],
                               FUN = sum)
kable(summary_hiv_cells)
```


```{r}
# summary of the number of HIV-specific cells (across subjecs, ignore cell type)
x <- aggregate(counts~patient+condition, 
               data = dt$tcrs_transformed[dt$tcrs_transformed$match_hiv==1,],
               FUN = sum)
x$N_cells <- NA
x$N_clones <- NA
for(i in 1:nrow(x)) {
  x$N_clones[i] <- sum(dt$tcrs_transformed$patient == x$patient[i])
  x$N_cells[i] <- sum(dt$tcrs_transformed$counts[dt$tcrs_transformed$patient == x$patient[i]])
}
x$p_hiv_cells <- x$counts/x$N_cells
```


```{r, fig.width=6, fig.height=3, fig.align='center'}
# you need R-package patchwork to stitch plot together
ggplot(data = x)+
  geom_point(aes(x = patient, y = p_hiv_cells, col = condition))+
  theme_bw(base_size = 10)+
  theme(legend.position = "top")+
  scale_x_discrete(breaks = sort(unique(dt$tcrs_transformed$patient)),
                   labels = sort(unique(dt$tcrs_transformed$patient)),
                   limits = sort(unique(dt$tcrs_transformed$patient)))|
  ggplot(data = x)+
  geom_point(aes(x = patient, y = counts, col = condition))+
  theme_bw(base_size = 10)+
  theme(legend.position = "top")+
  scale_x_discrete(breaks = sort(unique(dt$tcrs_transformed$patient)),
                   labels = sort(unique(dt$tcrs_transformed$patient)),
                   limits = sort(unique(dt$tcrs_transformed$patient)))
```
Compare with HIV specificity based on BLAST e-values < 1e-04:



```{r, echo=F}
# cleanup
rm(i, x, summary_hiv_cells,
   summary_hiv_clones)
```




```{r BLAST_pre, echo=F}

# load pre-computed files
load(file = "data/program_data/BLAST/BLAST_results.Rdata")
load(file = "data/program_data/BLAST/BLAST_short_results.Rdata")

# BLAST output

# plot all e-values
#plot(density(log(blast_results$E)))
#plot(density(log(blast_short_results$E)))

a = ggplot() +
  geom_density(aes(log(E), fill = "blast_results"), alpha = .25, data = blast_results) +
  geom_density(aes(log(E), fill = "blast_short_results"), alpha = .25, data = blast_short_results) +
  xlim (-17, 2.75) +
  ggtitle("Comparison of BLAST value density distributions") +
  labs(subtitle="With and without short sequence option")

# # number of all rows
# nrow(blast_results) # 3 884 023
# nrow(blast_short_results) # 4 111 644

CASKLSGTSGYNEQFF = filter(blast_results, QueryID == "CASKLSGTSGYNEQFF" )
CSFTGAVDTQYF = filter(blast_results, QueryID == "CSFTGAVDTQYF" )
CASWGQGAFNEQFF = filter(blast_results, QueryID == "CASWGQGAFNEQFF" )
CASRFLLANGNNEQFF = filter(blast_results, QueryID == "CASRFLLANGNNEQFF" )
CASSFSGSDEQFF = filter(blast_results, QueryID == "CASSFSGSDEQFF" )

CASKLSGTSGYNEQFF_s = filter(blast_short_results, QueryID == "CASKLSGTSGYNEQFF" )
CSFTGAVDTQYF_s = filter(blast_short_results, QueryID == "CSFTGAVDTQYF" )
CASWGQGAFNEQFF_s = filter(blast_short_results, QueryID == "CASWGQGAFNEQFF" )
CASRFLLANGNNEQFF_s = filter(blast_short_results, QueryID == "CASRFLLANGNNEQFF" )
CASSFSGSDEQFF_s = filter(blast_short_results, QueryID == "CASSFSGSDEQFF" )

# # row counts of example cdr3b sequences
# nrow(CASKLSGTSGYNEQFF) # 1386
# nrow(CASKLSGTSGYNEQFF_s) # 1293
# 
# nrow(CSFTGAVDTQYF) # 932
# nrow(CSFTGAVDTQYF_s) # 1484
# 
# nrow(CASWGQGAFNEQFF) # 2466
# nrow(CASWGQGAFNEQFF_s) # 2196
# 
# nrow(CASRFLLANGNNEQFF) # 1215
# nrow(CASRFLLANGNNEQFF_s) # 1011
# 
# nrow(CASSFSGSDEQFF) # 2500
# nrow(CASSFSGSDEQFF_s) # 2500

b = ggplot() +
  geom_density(aes(log10(E), fill = "CASKLSGTSGYNEQFF"), alpha = .25, data = CASKLSGTSGYNEQFF) +
  geom_density(aes(log10(E), fill = "CSFTGAVDTQYF"), alpha = .25, data = CSFTGAVDTQYF) +
  geom_density(aes(log10(E), fill = "CASWGQGAFNEQFF"), alpha = .25, data = CASWGQGAFNEQFF) +
  geom_density(aes(log10(E), fill = "CASRFLLANGNNEQFF"), alpha = .25, data = CASRFLLANGNNEQFF) +
  geom_density(aes(log10(E), fill = "CASSFSGSDEQFF"), alpha = .25, data = CASSFSGSDEQFF) +
  xlim (-5, 2.5) +
  ggtitle("Comparison of BLAST value density distributions") +
  labs(subtitle="For 5 randomly selected sequences")

c = ggplot() +
  geom_density(aes(log10(E), fill = "CASKLSGTSGYNEQFF_s"), alpha = .25, data = CASKLSGTSGYNEQFF_s) +
  geom_density(aes(log10(E), fill = "CSFTGAVDTQYF_s"), alpha = .25, data = CSFTGAVDTQYF_s) +
  geom_density(aes(log10(E), fill = "CASWGQGAFNEQFF_s"), alpha = .25, data = CASWGQGAFNEQFF_s) +
  geom_density(aes(log10(E), fill = "CASRFLLANGNNEQFF_s"), alpha = .25, data = CASRFLLANGNNEQFF_s) +
  geom_density(aes(log10(E), fill = "CASSFSGSDEQFF_s"), alpha = .25, data = CASSFSGSDEQFF_s) +
  xlim (-5, 2.5) +
  ggtitle("Comparison of BLAST short value density distributions") +
  labs(subtitle="For 5 randomly selected sequences, compared with short-sequence option")

# cleanup
rm(CASKLSGTSGYNEQFF, CSFTGAVDTQYF, CASWGQGAFNEQFF, CASRFLLANGNNEQFF, CASSFSGSDEQFF,
   CASKLSGTSGYNEQFF_s, CSFTGAVDTQYF_s, CASWGQGAFNEQFF_s, CASRFLLANGNNEQFF_s, CASSFSGSDEQFF_s)

# blast_results || blast_short_results
# all matches from all hiv specificity databases and patients
#  QueryID    patient cdr3b sequence
#  SubjectID  hiv specific sequence

# compare smallest top 100 e-values to clone count

# order by minimum -> leave to ggplot
# maybe instead of minimum 100 use cutoff-value

# top 100 of all? or unique?
# unique makes more sense, because other way double matches
# we are only interested in one possible match for each sequence

# # sanity check, whether all inputs are checked by both blast query strategies
# # 2 of 8455 seem to be cut off, supposedly too high e-values
# length(unique(blast_results$QueryID)) # 8453
# length(unique(blast_short_results$QueryID)) # 8453

## reduce table to minimum values and arrange by e-value

# # this here gives only the first result
blast_results_min = blast_results %>%
  group_by(QueryID) %>%
  dplyr::slice( which.min(E) )

blast_short_results_min = blast_short_results %>%
  group_by(QueryID) %>%
  dplyr::slice( which.min(E) )

# this here would give also double minima (9204 instead of 8453)
# blast_results_min = blast_results %>%
#   group_by(QueryID) %>%
#   filter( E == min(E)) %>%
#   distinct()
# could be somehow used... many minima = more likely to be hiv specific
# but doubles don't seem to be very high e-values in comparison
# and no perfect matches or one patient, so drop for now

# # in table form
# table(blast_results_min$QueryID)

d = ggplot() +
  geom_density(aes(log(E), fill = "blast_results_min"), alpha = .25, data = blast_results_min) +
  geom_density(aes(log(E), fill = "blast_short_results_min"), alpha = .25, data = blast_short_results_min) +
  xlim (-17, 2.75) +
  ggtitle("Comparison of BLAST value density distributions") +
  labs(subtitle="With and without short sequence option, only min values")

# decision to use short sequence option results 
# supposedly better fitting to examined relatively short patient sequences

## add min-e value and subject sequence to tcrs_transformed

# rename for merge
blast_short_results_min = blast_short_results_min %>%
  dplyr::rename("CDR3b" = "QueryID",
         "BLAST_e"  = "E",
         "BLAST_pattern"  = "SubjectID"
  )

# merge by CDR3b
dt$tcrs_transformed = merge(dt$tcrs_transformed,
                            blast_short_results_min[, c("CDR3b", "BLAST_pattern", "BLAST_e")],
                            by = "CDR3b",
                            all = TRUE)


# cleanup
rm(blast_results, blast_short_results,
   blast_results_min, blast_short_results_min)

```


```{r, echo=F}
# identity match, using e-values this time
dt$tcrs_transformed$match_hiv_e = ifelse(dt$tcrs_transformed$BLAST_e < 1e-04,
                                yes = 1, no = 0)

# summary of the number of HIV-specific clones
summary_hiv_clones <- aggregate(match_hiv_e~patient+condition+l1ctype, 
                                data = dt$tcrs_transformed,
                                FUN = sum)


# summary of the number of HIV-specific cells
summary_hiv_cells <- aggregate(counts~patient+condition+l1ctype, 
                               data = dt$tcrs_transformed[dt$tcrs_transformed$match_hiv_e==1,],
                               FUN = sum)

# summary of the number of HIV-specific cells (across subjecs, ignore cell type)
x <- aggregate(counts~patient+condition, 
               data = dt$tcrs_transformed[dt$tcrs_transformed$match_hiv_e==1,],
               FUN = sum)
x$N_cells <- NA
x$N_clones <- NA
for(i in 1:nrow(x)) {
  x$N_clones[i] <- sum(dt$tcrs_transformed$patient == x$patient[i])
  x$N_cells[i] <- sum(dt$tcrs_transformed$counts[dt$tcrs_transformed$patient == x$patient[i]])
}
x$p_hiv_cells <- x$counts/x$N_cells
```


```{r, fig.width=6, fig.height=3, fig.align='center', echo=F}
# you need R-package patchwork to stitch plot together
ggplot(data = x)+
  geom_point(aes(x = patient, y = p_hiv_cells, col = condition))+
  theme_bw(base_size = 10)+
  theme(legend.position = "top")+
  scale_x_discrete(breaks = sort(unique(dt$tcrs_transformed$patient)),
                   labels = sort(unique(dt$tcrs_transformed$patient)),
                   limits = sort(unique(dt$tcrs_transformed$patient)))|
  ggplot(data = x)+
  geom_point(aes(x = patient, y = counts, col = condition))+
  theme_bw(base_size = 10)+
  theme(legend.position = "top")+
  scale_x_discrete(breaks = sort(unique(dt$tcrs_transformed$patient)),
                   labels = sort(unique(dt$tcrs_transformed$patient)),
                   limits = sort(unique(dt$tcrs_transformed$patient)))

# cleanup
rm(i, x, summary_hiv_cells,
   summary_hiv_clones)
```



### Sequence Similarity

Three different methods were used to compare patient sequences with sequences of the HIV specificity databases.

1) Damerau-Levensthein was used to identify perfect matches and matches with distant 1, which were used in the previous section to categorize potentially HIV specific sequences.

2) <a href="./src/02_dataTransformation/blast_analysis.R" target="_blank">blosum_analysis</a> To gain more biologically meaningful comparison results, the scoring matrix BLOSUM62 was implemented and compared to the Damerau-Levensthein distance results.

3) <a href="./src/02_dataTransformation/blast_analysis.R" target="_blank">blast_analysis</a>. Because comparison of BLOSUM62 scores took more time than expected, at some point the decision was made to integrate the Basic Local Alignment Search Tool (BLAST) from <https://blast.ncbi.nlm.nih.gov/Blast.cgi>. 

#### Method Comparison

BLOSUM62 method scored comparison of amino-acids with the help of the BLOSUM62 Block Substitution Matrix.
The higher the score, the more conservative / biologically reasonable the distance between sequences. <br>
gapOpening set to "11" and gapExtension to "1" based on algorithm parameters of BLAST <https://blast.ncbi.nlm.nih.gov/Blast.cgi?PAGE=Proteins>.
z-Score computed with mean and sd of all patient distributions.

BLAST method used with short-blastp option. Parameters left to default. Low e-values equal rarer to be expected occurance of sequence.

```{r blosum62_vs_dl, echo=FALSE}
six_patients = filter(dt$tcrs_transformed, patient != "EC2" & patient != "EC5")

ggplot() +
   geom_density(aes(BLOSUM62_score, fill = as.factor(dl_dist)), alpha = .5, data = six_patients) +
   ggtitle("BLOSUM62 maxScore vs Damerau-Levensthein") +
   labs(subtitle = "0 <-> Perfect Match | 1 <-> DL = 1 | NA <-> DL > 1")

ggplot() +
   geom_density(aes(BLOSUM62_zscore, fill = as.factor(dl_dist)), alpha = .5, data = six_patients) +
   ggtitle("BLOSUM62 maxScore z-Score vs Damerau-Levensthein") +
   labs(subtitle = "0 <-> Perfect Match | 1 <-> DL = 1 | NA <-> DL > 1")

ggplot() +
   geom_density(aes(-log(BLAST_e), fill = as.factor(dl_dist)), alpha = .5, data = six_patients) +
   ggtitle("BLAST e-value (inverted for comparison) vs Damerau-Levensthein") +
   labs(subtitle = "0 <-> Perfect Match | 1 <-> DL = 1 | NA <-> DL > 1")

ggplot(six_patients, aes(-log(BLAST_e), BLOSUM62_zscore)) +
  geom_point() +
  geom_smooth(method=lm , color=custom_blue, fill="red") +
  ggtitle("BLAST e-value (inverted for comparison) vs BLOSUM62 z-score")

rm(six_patients)

```
```{r blosum62_SUDO, echo=F}

## SUDO Code

# 1 - Compute scores for patient cdr3b sequences with specificity data sets
#     Save for faster execution (maybe transfer to dataTransformation part)

# -> see data transformation / computeBLOSUM62 function

# 2a - Compute scores for GLIPH reference database with specificity data sets
#     Also save for better efficiency

# -> maxScore 
#   1) compare every sequence with specificity databases (prefiltered for HIV)
#   2) look for maximum score, safe score and sequence
# 
# ## WORK IN PROGRESS
# 
# # -> z-Score (difference to mean, normalized by SD)
# #   1) compare every sequence with specificity databases (prefiltered for HIV)
# #   2) look for maximum z-Score (z = (x – μ)/σ)
# 
# 
# ## all scores now saved under dt$bl62_scores
# 
# head(dt$bl62_scores[1:3])
# 
# ## computed bl62_scores for 10000 randomly sampled rows of GLIPHs ref_cd48
# 
# bl62_scores_ref_path = "data/program_data/bl62_scores_ref.Rdata"
# get(load(file = bl62_scores_ref_path))
# 
# head(bl62_scores_ref[1:4])
# 
# ## compute bl62 z-scores for double checking (>6 SD seems rather high)
# 
# ## 1) Calculate with mean/sd of individual columns (used until now)
# 
# bl62_zscores_columnwise = dt$bl62_scores
# 
# for (i in 2:length(bl62_zscores_columnwise)) {
#   mean = mean(bl62_zscores_columnwise[[i]])
#   sd = sd(bl62_zscores_columnwise[[i]])
#   bl62_zscores_columnwise[[i]] = (bl62_zscores_columnwise[[i]] - mean) / sd
# }
# 
# rm(mean, sd, bl62_scores_ref_path)
# 
# 
# 
# ## 2) Calculate with mean/sd of all columns of ref db or patient db
# 
# bl62_zscores_patientwise = dt$bl62_scores
# 
# mean = mean(as.matrix(bl62_zscores_patientwise[, c(2:length(bl62_zscores_patientwise)) ])) 
# # mean = 18.27672
# 
# sd = sd(as.matrix(bl62_zscores_patientwise[, c(2:length(bl62_zscores_patientwise)) ])) 
# # sd = 10.89783
# 
# for (i in 2:length(bl62_zscores_patientwise)) {
#   bl62_zscores_patientwise[[i]] = (bl62_zscores_patientwise[[i]] - mean) / sd
# }
# 
# rm(mean, sd)
# 
# 
# 
# bl62_zscores_refdbwise = bl62_scores_ref
# 
# mean = mean(as.matrix(bl62_zscores_refdbwise[, c(4:length(bl62_zscores_refdbwise)) ])) 
# # mean = 17.83905
# 
# sd = sd(as.matrix(bl62_zscores_refdbwise[, c(4:length(bl62_zscores_refdbwise)) ])) 
# # sd = 11.07101
# 
# for (i in 4:length(bl62_zscores_refdbwise)) {
#   bl62_zscores_refdbwise[[i]] = (bl62_zscores_refdbwise[[i]] - mean) / sd
# }
# 
# rm(mean, sd)
# 
# 
# ## 3) calculate scores columnwise for the reference database
# 
# bl62_zscores_ref_columnwise = bl62_scores_ref
# 
# for (i in 4:length(bl62_zscores_ref_columnwise)) {
#   mean = mean(bl62_zscores_ref_columnwise[[i]])
#   sd = sd(bl62_zscores_ref_columnwise[[i]])
#   bl62_zscores_ref_columnwise[[i]] = (bl62_zscores_ref_columnwise[[i]] - mean) / sd
# }
# 
# rm(mean, sd)
# 
# ## 4) calculate z-score for cdr3b of patient against mean and sd of reference db cdr3b
# # computed in the same way, so no need to match cdr3b's
# 
# bl62_z_patient_vs_ref = dt$bl62_scores
# 
# for (i in 4:length(bl62_scores_ref)) {
#   mean = mean(bl62_scores_ref[[i]])
#   sd = sd(bl62_scores_ref[[i]])
#   bl62_z_patient_vs_ref[[i-2]] = (bl62_z_patient_vs_ref[[i-2]] - mean) / sd
# }
# 
# rm(mean, sd)
# 
# ## 5) safe z-score into matching row of tcrs_transformed data table
# 
# # has to be matched, because unique number of cdr3b has been taken to compute scores
# 
# # idea:
# # maximum ref z-score should match maximum blosum score
# # take maximum z-score for every cdr3b
# 
# tcrs_transformed = dt$tcrs_transformed
# 
# for (i in 1:nrow(tcrs_transformed))
# {
#   tcrs_transformed$BLOSUM62_zscore_ref[i]  = max(bl62_z_patient_vs_ref[[tcrs_transformed$CDR3b[i]]])
# }
# 
# # numbers don't make much sense, maybe wrong idea to take maximum?
# 
# # looks different
# plot(tcrs_transformed$BLOSUM62_zscore, tcrs_transformed$BLOSUM62_zscore_ref)

## P_VALUE TESTS (deprecated)

# -> compute density of BLOSUM62 score with reference db for every tested sequence
# -> to avoid overhead, instantly compute p-value

# 2b - Compare alignment scores of patients and reference database
#     Goal: random noise reduction, identification of high scores / HIV specificity

# -> compute p-Value between maxScore of patient vs score density of ref db
# -> try cutoff value (f.e. p <= 0.05 or p <= 0.01) and compare with Damerau-Levensthein matches
# -> Use Bonferroni or Benjamini-Hochberg correction to counteract alpha-failure cumulation
```

#### BLAST

BLAST was installed locally as a command line tool and called with the helped of the rBLAST package. The standard BLAST algorithm was compared with the use of the short-blastp option. Results of the short-blastp algorithm were then joined to the patient data table, in form of the minimal e-value for every CDR3b sequence and the matched HIV specific pattern. 

##### Standard algorithm vs algorithm with short-blastp option

```{r BLAST_display, echo=F}

# display the comparisons
a
d 
c
b


# cleanup
rm(a, b, c, d)

```
#### BLAST and clonal expansion

```{r blast_clonal_expansion, echo=FALSE}

ggplot(dt$tcrs_transformed, aes(log(BLAST_e),counts)) +
  geom_point() +
  geom_smooth(method=lm , color=custom_blue, fill="red") +
  ggtitle("BLAST e-value vs clonal expansion")

min_200 = dt$tcrs_transformed[order(dt$tcrs_transformed$BLAST_e),][1:200,]

ggplot(min_200, aes(log(BLAST_e), log(counts))) +
  geom_point() +
  geom_smooth(method=lm , color=custom_blue, fill="red") +
  ggtitle("BLAST e-value vs clonal expansion") +
  labs(subtitle="Minimum 200 e-values")

rm(min_200)

```

## CDR3b Generation Probability

The probability of the CDR3b sequences being randomly generated was checked with the help of the Olga (Optimized Likelihood estimate of immunoGlobulin Amino-acid sequences) command line tool <https://github.com/statbiophys/OLGA>. V-Genes and J-Genes were passed as arguments to Olga. Length of the sequences seemed to be long enough to not produce random results in regards to the Levensthein distance <= 1. Probabilities for randomly generated CDR3b sequences seem to be low.

```{r olga_check, echo=FALSE}
#plot(density(nchar(dt$tcrs_transformed$CDR3b)), main = "CDR3b Sequence Length")
hist(nchar(dt$tcrs_transformed$CDR3b), 
     main ="CDR3b Sequence Length",
     xlab="Length in AA",
     freq=F,
     col=custom_blue)


a = filter(dt$tcrs_transformed, match_hiv == 1)
dl_0 = filter(dt$tcrs_transformed, dl_dist == 0 )
dl_1 = filter(dt$tcrs_transformed, dl_dist == 1 )
bl_65 = filter(dt$tcrs_transformed, BLOSUM62_score >= 65)
bl_70 = filter(dt$tcrs_transformed, BLOSUM62_score >= 70)
bl_75 = filter(dt$tcrs_transformed, BLOSUM62_score >= 75)

bl_z5 = filter(dt$tcrs_transformed, BLOSUM62_zscore >= 5)
bl_z6 = filter(dt$tcrs_transformed, BLOSUM62_zscore >= 6)
#bl_z7 = filter(dt$tcrs_transformed, BLOSUM62_zscore >= 7)
#bl_z8 = filter(dt$tcrs_transformed, BLOSUM62_zscore >= 8) zero matches

all_sub0 = sample_n(dt$tcrs_transformed, nrow(dl_0))
all_sub1 = sample_n(dt$tcrs_transformed, nrow(dl_0))
all_sub2 = sample_n(dt$tcrs_transformed, nrow(dl_0))
all_sub3 = sample_n(dt$tcrs_transformed, nrow(dl_0))
all_sub4 = sample_n(dt$tcrs_transformed, nrow(dl_0))
all_sub5 = sample_n(dt$tcrs_transformed, nrow(dl_0))
all_sub6 = sample_n(dt$tcrs_transformed, nrow(dl_0))
all_sub7 = sample_n(dt$tcrs_transformed, nrow(dl_0))
all_sub8 = sample_n(dt$tcrs_transformed, nrow(dl_0))
all_sub9 = sample_n(dt$tcrs_transformed, nrow(dl_0))

ggplot() +
  geom_density(aes(log10(p_gen), fill = "HIVSpecific_dl_0_and_1"), alpha = .25, data = a) +
  geom_density(aes(log10(p_gen), fill = "All"), alpha = .5, data = dt$tcrs_transformed, na.rm = T) +
  scale_fill_manual(name = "dataset", values = c(HIVSpecific_dl_0_and_1 = custom_blue, All = "gray70")) +
  xlim (-20, -5) +
  ggtitle("Random CDR3b Generation Probability - Computed with OLGA") + 
  labs(subtitle="Matches computed with Damerau-Levensthein distance <= 1")

ggplot() +
  geom_density(aes(log10(p_gen), fill = "HIVSpecific_dl0"), alpha = .25, data = dl_0) +
  geom_density(aes(log10(p_gen), fill = "All"), alpha = .5, data = dt$tcrs_transformed, na.rm = T) +
  scale_fill_manual(name = "dataset", values = c(HIVSpecific_dl0 = custom_blue, All = "gray70")) +
  xlim (-20, -5) +
  ggtitle("Random CDR3b Generation Probability - Computed with OLGA") + 
  labs(subtitle="Perfect matches with Damerau-Levensthein distance = 0 ")

ggplot() +
  geom_density(aes(log10(p_gen), fill = "HIVSpecific_dl0"), alpha = .25, data = dl_0) +
  geom_density(aes(log10(p_gen), fill = "All_0"), alpha = .1, 
               data = all_sub0, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_1"), alpha = .1, 
               data = all_sub1, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_2"), alpha = .1, 
               data = all_sub2, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_3"), alpha = .1, 
               data = all_sub3, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_4"), alpha = .1, 
               data = all_sub4, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_5"), alpha = .1, 
               data = all_sub5, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_6"), alpha = .1, 
               data = all_sub6, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_7"), alpha = .1, 
               data = all_sub7, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_8"), alpha = .1, 
               data = all_sub8, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_9"), alpha = .1, 
               data = all_sub9, na.rm = T) +
  scale_fill_manual(name = "dataset", 
                    values = c(HIVSpecific_dl0 = custom_blue, All_0 = "gray70", 
                               All_1 = "gray70", All_2 = "gray70", All_3 = "gray70",
                               All_4 = "gray70", All_5 = "gray70", All_6 = "gray70",
                               All_7 = "gray70", All_8 = "gray70", All_9 = "gray70")
                    ) +
  xlim (-20, -5) +
  ggtitle("Random CDR3b Generation Probability - Computed with OLGA") + 
  labs(subtitle="Perfect matches with DL distance = 0, All sampled to comparable size of dl_0 (23 rows)")


ggplot() +
  geom_density(aes(log10(p_gen), fill = "HIVSpecific_dl_1"), alpha = .25, data = dl_1) +
  geom_density(aes(log10(p_gen), fill = "HIVSpecific_dl_0"), alpha = .25, data = dl_0) +
  geom_density(aes(log10(p_gen), fill = "All"), alpha = .25, data = dt$tcrs_transformed, na.rm = T) +
  scale_fill_manual(name = "dataset", values = c(HIVSpecific_dl_0 = custom_blue, HIVSpecific_dl_1 = "cyan", All = "gray70" )) +
  xlim (-20, -5) +
  ggtitle("Random CDR3b Generation Probability - Computed with OLGA") + 
  labs(subtitle="Matches with Damerau-Levensthein distance = 0 or 1")

ggplot() +
  geom_density(aes(log10(p_gen), fill = "HIVSpecific_bl65"), alpha = .25, data = bl_65) +
  geom_density(aes(log10(p_gen), fill = "All"), alpha = .5, data = dt$tcrs_transformed, na.rm = T) +
  scale_fill_manual(name = "dataset", values = c(HIVSpecific_bl65 = custom_blue, All = "gray70")) +
  xlim (-20, -5) +
  ggtitle("Random CDR3b Generation Probability - Computed with OLGA") +
  labs(subtitle="BLOSUM62 score bigger than 65")

ggplot() +
  geom_density(aes(log10(p_gen), fill = "BL_65"), alpha = .25, data = bl_65) +
  geom_density(aes(log10(p_gen), fill = "BL_70"), alpha = .25, data = bl_70) +
  geom_density(aes(log10(p_gen), fill = "BL_75"), alpha = .25, data = bl_75) +
  geom_density(aes(log10(p_gen), fill = "All"), alpha = .5, data = dt$tcrs_transformed, na.rm = T) +
  scale_fill_manual(name = "dataset", values = c(BL_65 = custom_blue, BL_70 = "blue",
                                                 BL_75 = "cyan", All = "gray70")) +
  xlim (-20, -5) +
  ggtitle("Random CDR3b Generation Probability - Computed with OLGA") +
  labs(subtitle="BLOSUM62 score bigger than 65, 70 or 75")

all_sub0 = sample_n(dt$tcrs_transformed, nrow(bl_65))
all_sub1 = sample_n(dt$tcrs_transformed, nrow(bl_65))
all_sub2 = sample_n(dt$tcrs_transformed, nrow(bl_65))
all_sub3 = sample_n(dt$tcrs_transformed, nrow(bl_65))
all_sub4 = sample_n(dt$tcrs_transformed, nrow(bl_65))
all_sub5 = sample_n(dt$tcrs_transformed, nrow(bl_65))
all_sub6 = sample_n(dt$tcrs_transformed, nrow(bl_65))
all_sub7 = sample_n(dt$tcrs_transformed, nrow(bl_65))
all_sub8 = sample_n(dt$tcrs_transformed, nrow(bl_65))
all_sub9 = sample_n(dt$tcrs_transformed, nrow(bl_65))

ggplot() +
  geom_density(aes(log10(p_gen), fill = "HIVSpecific"), alpha = .25, data = bl_65) +
  geom_density(aes(log10(p_gen), fill = "All_0"), alpha = .1, 
               data = all_sub0, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_1"), alpha = .1, 
               data = all_sub1, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_2"), alpha = .1, 
               data = all_sub2, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_3"), alpha = .1, 
               data = all_sub3, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_4"), alpha = .1, 
               data = all_sub4, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_5"), alpha = .1, 
               data = all_sub5, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_6"), alpha = .1, 
               data = all_sub6, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_7"), alpha = .1, 
               data = all_sub7, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_8"), alpha = .1, 
               data = all_sub8, na.rm = T) +
  geom_density(aes(log10(p_gen), fill = "All_9"), alpha = .1, 
               data = all_sub9, na.rm = T) +
  scale_fill_manual(name = "dataset", 
                    values = c(HIVSpecific = custom_blue, All_0 = "gray70", 
                               All_1 = "gray70", All_2 = "gray70", All_3 = "gray70",
                               All_4 = "gray70", All_5 = "gray70", All_6 = "gray70",
                               All_7 = "gray70", All_8 = "gray70", All_9 = "gray70")
                    ) +
  xlim (-20, -5) +
  ggtitle("Random CDR3b Generation Probability - Computed with OLGA") + 
  labs(subtitle="BLOSUM62 score bigger than 65, All sampled to comparable size of bl_65 (1666 rows)")

ggplot() +
  geom_density(aes(log10(p_gen), fill = "bl62_z5"), alpha = .25, data = bl_z5) +
  geom_density(aes(log10(p_gen), fill = "All"), alpha = .5, data = dt$tcrs_transformed, na.rm = T) +
  scale_fill_manual(name = "dataset", values = c(bl62_z5 = custom_blue, All = "gray70")) +
  xlim (-20, -5) +
  ggtitle("Random CDR3b Generation Probability - Computed with OLGA") +
  labs(subtitle="BLOSUM62 zscore bigger than 5")

ggplot() +
  geom_density(aes(log10(p_gen), fill = "bl62_z5"), alpha = .25, data = bl_z5) +
  geom_density(aes(log10(p_gen), fill = "bl62_z6"), alpha = .25, data = bl_z6) +
  #geom_density(aes(log10(p_gen), fill = "bl62_z7"), alpha = .25, data = bl_z7) +
  geom_density(aes(log10(p_gen), fill = "All"), alpha = .5, data = dt$tcrs_transformed, na.rm = T) +
  xlim (-20, -5) +
  ggtitle("Random CDR3b Generation Probability - Computed with OLGA") +
  labs(subtitle="BLOSUM62 zscore bigger than 5,6,7 and 8")

## ggforce - ggsina plot

ggplot(dt$tcrs_transformed, aes(patient, p_gen)) +
  scale_y_log10() + 
  geom_sina(aes(colour = match_hiv)) + 
  ggtitle("Random CDR3b Generation Probability - HIV vs All Subject Sina Plot") +
  labs(subtitle="non-finite values caused by probabilities near zero")

ggplot(dt$tcrs_transformed, aes(patient, p_gen)) +
  scale_y_log10() + 
  geom_sina(aes(colour = as.factor(match_hiv))) + 
  ggtitle("Random CDR3b Generation Probability - HIV vs All Subject Sina Plot") +
  labs(subtitle="non-finite values caused by probabilities near zero")

ggplot(dt$tcrs_transformed, aes(patient, p_gen)) +
  scale_y_log10() + 
  geom_sina(aes(colour = as.factor(dl_dist))) + 
  ggtitle("Random CDR3b Generation Probability - HIV vs All Subject Sina Plot") +
  labs(subtitle="non-finite values caused by probabilities near zero")

ggplot(dt$tcrs_transformed, aes(patient, p_gen)) +
  scale_y_log10() + 
  geom_sina(aes(colour = BLOSUM62_score)) + # factor stopped working somehow
  ggtitle("Random CDR3b Generation Probability - BLOSUM62 Score")

set.seed(1)

ggplot(sample_n(dt$tcrs_transformed, 8500), aes(patient, p_gen)) +
  scale_y_log10() + 
  geom_sina(aes(colour = as.factor(BLOSUM62_score))) + 
  ggtitle(" BLOSUM62 Score as factor") + 
  labs(subtitle = "Sampled 8500 rows")

set.seed(NULL)

# g = ggplot(filter(dt$tcrs_transformed, patient != "EC2" & patient != "EC5"), aes(patient, p_gen)) +
#    scale_y_log10() + 
#    geom_sina(aes(colour = as.factor(BLOSUM62_score))) + 
#    ggtitle("BLOSUM62 Score as factor") +
#    labs(subtitle = "Sampled all rows")

# g = ggplot(filter(dt$tcrs_transformed, patient != "EC2" & patient != "EC5"), aes(BLOSUM62_score, p_gen)) +
#    scale_y_log10() +
#    geom_sina(aes(colour = as.factor(match_hiv))) +
#    ggtitle("BLOSUM62 Score vs generation probability") +
#    labs(subtitle = "Match_hiv (dl <=1) as factor (probably not really representative, to be checked)")
# 
# g + facet_wrap(vars(patient))

# compare against BLAST e-values
ggplot(dt$tcrs_transformed, aes(patient, p_gen)) +
  scale_y_log10() + 
  geom_sina(aes(colour = log(BLAST_e))) + 
  ggtitle("Random CDR3b Generation Probability - BLAST e-value")

test = dt$tcrs_transformed

# create custom factor stages with cut function for deeper visualisation
test$BLAST_e_cat = cut(test$BLAST_e, breaks=c(1e-07, 1e-06, 1e-05, 1e-04, 1e-03, 1e-02, 1e-01, 1, 10))

ggplot(test, aes(patient, p_gen)) +
  scale_y_log10() + 
  geom_sina(aes(colour = as.factor(BLAST_e_cat))) + 
  ggtitle(" BLAST e-value as factor") #+ 
  #labs(subtitle = "Sampled 8500 rows")

rm(a, dl_0, dl_1, bl_65, all_sub0,all_sub1, all_sub2, all_sub3, all_sub4, all_sub5,
    all_sub6, all_sub7, all_sub8, all_sub9, bl_70, bl_75, bl_z5, bl_z6, test)# bl_z7)

```


## Repertoire Overlap

Computed with immunarch. No overlap in repertoires is to be seen except for 
Patient EC2, Patient EC5 and [Patient EC2+5], which makes sense because samples 
come from the same person. Also found some overlap of [Patient EC1] between 
CD4T and CD8T cells.

Some remarks:

  * what are the inputs? (e.g. CDR3 sequence, clone numbers, V, D, J gene, etc.)
  * do we understand the overlap metrics?
  * function repOverlap have many parameters. We ought to be aware of their 
    effects (e.g. bootstrap, downsample). *Caveat*: poor package documentation
  
### Overlap with method = "public"
Public index = "number of public clonotypes" (based on documentation). 
**TODO:** How is "public" clone defined?

```{r repertoire_overlap_public, echo=FALSE, fig.width=6, fig.height=5}
rep_overlap = repOverlap(dt$ia_list, .method = "public", .verbose = F)
vis(rep_overlap, .text.size = 3)
```


```{r repertoire_overlap_heatmap, echo=FALSE, fig.width=6, fig.height=5}
vis(rep_overlap, "heatmap2", .text.size = 3)
```


```{r repertoire_overlap_cleanup}
rm(rep_overlap)
```

### Overlap with method = "jaccard"
Jaccard index: $J = |A\cap B|/|A\cup B|$ with A, B as two TCR repertoires

Low $J$ between EC2 and EC5, yet still larger than $J$ between any other pair 
of samples.

Again: we have to be sure what are the inputs to interpret this plot.

```{r repertoire_overlap_jaccard, echo=FALSE, fig.width=6, fig.height=5}
rep_overlap = repOverlap(dt$ia_list, .method = "overlap", .verbose = F)
vis(rep_overlap, .text.size = 2)
rm(rep_overlap)
```
### Overlap with method = "overlap"
Overlap index $O = |A\cap B|/\min({|A|, |B|})$ with A, B as two TCR repertoires

Similar results as those based on the Jaccard index.

```{r repertoire_overlap, echo=FALSE, fig.width=6, fig.height=5}
rep_overlap = repOverlap(dt$ia_list, .method = "overlap", .verbose = F)
vis(rep_overlap, .text.size = 2)
rm(rep_overlap)
```





```{r, echo = F}

### Some immunarch input tests

# Available entries in the input data

# .data doc:blosum
# - "Clones" - number of barcodes (events, UMIs) or reads;
# - "Proportion" - proportion of barcodes (events, UMIs) or reads;
# - "CDR3.nt" - CDR3 nucleotide sequence;
# - "CDR3.aa" - CDR3 amino acid sequence;
# - "V.name" - names of aligned Variable gene segments;
# - "D.name" - names of aligned Diversity gene segments or NA;
# - "J.name" - names of aligned Joining gene segments;
# - "V.end" - last positions of aligned V gene segments (1-based);
# - "D.start" - positions of D'5 end of aligned D gene segments (1-based);
# - "D.end" - positions of D'3 end of aligned D gene segments (1-based);
# - "J.start" - first positions of aligned J gene segments (1-based);
# - "VJ.ins" - number of inserted nucleotides (N-nucleotides) at V-J junction (-1 for receptors with VDJ recombination);
# - "VD.ins" - number of inserted nucleotides (N-nucleotides) at V-D junction (-1 for receptors with VJ recombination);
# - "DJ.ins" - number of inserted nucleotides (N-nucleotides) at D-J junction (-1 for receptors with VJ recombination);
# - "Sequence" - full nucleotide sequence.


# .col doc:
# A string that specifies the column(s) to be processed. Pass one of the 
# following strings, separated by the plus sign: "nt" for nucleotide sequences, 
# "aa" for amino acid sequences, "v" for V gene segments, "j" for J gene segments. 
# E.g., pass "aa+v" to compute overlaps on CDR3 amino acid sequences paired with 
# V gene segments, i.e., in this case a unique clonotype is a pair of CDR3 amino 
# acid and V gene segment. Clonal counts of equal clonotypes will be summed up.

# .col input defines which columns are used (default: .col = "aa")
# Hence only the CDR3.aa column have been used so far
# Alternative .col = "aa+V" for 



# CDR3.aa + Clones as input -> this shold give the same result for method = "overlap" as before
# tmp <- dt$ia_list
# tmp <- lapply(X = tmp, FUN = function(x) {return(data.frame(CDR3.aa = x[, "CDR3.aa"], 
#                                                             Clones = x[, "Clones"]))})
# rep_overlap = repOverlap(tmp, .method = "overlap", .verbose = F)
# vis(rep_overlap)
# rm(rep_overlap,tmp)
```

## Diversity Analysis

To perform diversity analysis the R package vegan was used. As expected from the [Repertoire Overlap], the sample diversity curves seem to be almost linear steep. Extrapolated richness of Chao1 and ACE values are also reported. 

```{r rarefaction, echo=FALSE}

# # test data
# data(dune)
# 
# # 30 species (columns) x 20 places (rows) + occurences (counts)
# head(dune)
# 
# # input into rarecurve function
# rarecurve(dune, col = custom_blue)

# so in our case
# rows    -> patients
# columns -> cdr3b
# counts  -> clonal expansions

# build for every patient
EC1 = filter(dt$tcrs_transformed, patient == "EC1")[,c("CDR3b", "counts")]
EC1 = setNames(data.frame(t(EC1[ , - 1])), EC1[ , 1])

EC2_5 = filter(dt$tcrs_transformed, patient == "EC2+5")[,c("CDR3b", "counts")]
EC2_5 = setNames(data.frame(t(EC2_5[ , - 1])), EC2_5[ , 1])

EC4 = filter(dt$tcrs_transformed, patient == "EC4")[,c("CDR3b", "counts")]
EC4 = setNames(data.frame(t(EC4[ , - 1])), EC4[ , 1])

NEC1 = filter(dt$tcrs_transformed, patient == "NEC1")[,c("CDR3b", "counts")]
NEC1 = setNames(data.frame(t(NEC1[ , - 1])), NEC1[ , 1])

NEC2 = filter(dt$tcrs_transformed, patient == "NEC2")[,c("CDR3b", "counts")]
NEC2 = setNames(data.frame(t(NEC2[ , - 1])), NEC2[ , 1])

NEC4 = filter(dt$tcrs_transformed, patient == "NEC4")[,c("CDR3b", "counts")]
NEC4 = setNames(data.frame(t(NEC4[ , - 1])), NEC4[ , 1])

all_patients = as.data.frame(rbindlist(list(EC1, EC2_5, EC4, NEC1, NEC2, NEC4), fill=T))
rownames(all_patients) = c("EC1","EC2+5", "EC4", "NEC1", "NEC2", "NEC4")
all_patients[is.na(all_patients)] = 0

# all patients
rarecurve(all_patients, ylab="Clones", col = custom_blue)

# ec
rarecurve(all_patients[1:3,], ylab="Clones", col = custom_blue)

# nec
rarecurve(all_patients[4:6,], ylab="Clones", col = custom_blue)

# Chao and ACE
cat("\n Chao1 and ACE for all patients individually \n \n")
estimateR(all_patients)

cat("\n Chao1 and ACE for all patients together \n \n")
estimateR(colSums(all_patients))



# cleanup
rm(EC1, EC2_5, EC4, NEC1, NEC2, NEC4, all_patients)

```






## Motif Enrichment

Comparison of Gliphs output for selected enriched motifs. No duplicates were found.


```{r motif_enrichment, echo=FALSE}
EC1_CD4T = tg$EC1_CD4T$motif_enrichment$selected_motifs
EC1_CD4T$patient = "EC1"
EC1_CD4T$celltype = "CD4T"
EC1_CD8T = tg$EC1_CD8T$motif_enrichment$selected_motifs
EC1_CD8T$patient = "EC1"
EC1_CD8T$celltype = "CD8T"

EC2_5_CD4T = tg$EC2_5_CD4T$motif_enrichment$selected_motifs
EC2_5_CD4T$patient = "EC2_5"
EC2_5_CD4T$celltype = "CD4T"
EC2_5_CD8T = tg$EC2_5_CD8T$motif_enrichment$selected_motifs
EC2_5_CD8T$patient = "EC2_5"
EC2_5_CD8T$celltype = "CD8T"

EC4_CD4T = tg$EC4_CD4T$motif_enrichment$selected_motifs
EC4_CD4T$patient = "EC4"
EC4_CD4T$celltype = "CD4T"
EC4_CD8T = tg$EC4_CD8T$motif_enrichment$selected_motifs
EC4_CD8T$patient = "EC4"
EC4_CD8T$celltype = "CD8T"

# No CD4T motifs for NEC1
#NEC1_CD4T = tg$NEC1_CD4T$motif_enrichment$selected_motifs
#NEC1_CD4T$patient = "NEC1"
#NEC1_CD4T$celltype = "CD4T"
NEC1_CD8T = tg$NEC1_CD8T$motif_enrichment$selected_motifs
NEC1_CD8T$patient = "NEC1"
NEC1_CD8T$celltype = "CD8T"

NEC2_CD4T = tg$NEC2_CD4T$motif_enrichment$selected_motifs
NEC2_CD4T$patient = "NEC2"
NEC2_CD4T$celltype = "CD4T"
NEC2_CD8T = tg$NEC2_CD8T$motif_enrichment$selected_motifs
NEC2_CD8T$patient = "NEC2"
NEC2_CD8T$celltype = "CD8T"

NEC4_CD4T = tg$NEC4_CD4T$motif_enrichment$selected_motifs
NEC4_CD4T$patient = "NEC4"
NEC4_CD4T$celltype = "CD4T"
NEC4_CD8T = tg$NEC4_CD8T$motif_enrichment$selected_motifs
NEC4_CD8T$patient = "NEC4"
NEC4_CD8T$celltype = "CD8T"

a = rbind(EC1_CD4T,   EC1_CD8T,
          EC2_5_CD4T, EC2_5_CD8T,
          EC4_CD4T,   EC4_CD8T,
          #NEC1_CD4T,  
          NEC1_CD8T,
          NEC2_CD4T,  NEC2_CD8T,
          NEC4_CD4T,  NEC4_CD8T)

a = a[order(a$OvE),]

a$duplicate = duplicated(a$Motif)

a

rm(EC1_CD4T,   EC1_CD8T,
   EC2_5_CD4T, EC2_5_CD8T,
   EC4_CD4T,   EC4_CD8T,
   #NEC1_CD4T,  
   NEC1_CD8T,
   NEC2_CD4T,  NEC2_CD8T,
   NEC4_CD4T,  NEC4_CD8T,
   a)



```


## Patient EC1

CD4 T-cells don't seem to be depleted in comparison to CD8 T-cells, which could contribute to the hypothesis of [NEC CD4 T-Cell Depleation]. Cell count seems to be ok in comparison, although relatively low. <br> Small amount of [Repertoire Overlap] found for CD4T and CD8T cells, suspected to be caused by measurement inaccuracies leading to wrong cell characterization.

```{r EC1_counts, echo=FALSE}
#aggregate(list(clone_count=dt$EC1_CD48T$counts), list(cell_type = dt$EC1_CD48T$l1ctype), sum)           
ec1 = filter(clones_and_cellcounts, Patient == "EC1") 
ec1$Patient = NULL
print(ec1,row.names = FALSE)
rm(ec1)
```
Checking for [HIV Specificity] revealed two perfect matches for CD8T cells.

```{r EC1_specificity, echo=FALSE}

a = filter(dt$tcrs_transformed, patient == "EC1")
a = filter(a, dl_dist == 0)

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

rm(a)


```

Checking for [HIV Specificity] with Damerau-Levenshtein distance <= 1 revealed 50 matches for CD4T and CD8T cells.

```{r EC1_specificity_dl1, echo=FALSE}

#cat("Annotation Matches - Damerau-Levenshtein distance <= 1")

#subset_specificity_dl1('EC1_CD4T','EC1_CD8T')

a = filter(dt$tcrs_transformed, patient == "EC1")
a = filter(a, match_hiv == 1)

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

#plot(density(a$p_gen), main = "Random CDR3b Generation Probability")

rm(a)

```

Checking for [HIV Specificity] based on a BLAST e-value < 1e-04 (roughly based on all patients e-value for perfect matches) revealed 100 matches for CD4T and CD8T cells, as well as cells being marked as Mono, NK and other T.

```{r EC1_specificity_BLAST, echo=FALSE}

a = filter(dt$tcrs_transformed, patient == "EC1")
a = filter(a, BLAST_e < 1e-04)
a = a[order(a$l1ctype, a$BLAST_e),]

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

rm(a)

```

### EC1 - CD4 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC1_CD4T, min_vertex_size = 3)

# Plot igraph with some attributes taken from original visnet object
# More options/transformations are possible.

# Be aware: gliph discards singleton vertices, these are not shown in the below network (perhaps they cannot be shown due to their large number) even though they may contain a high number of clonal members.

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r EC1_CD4_plot, include=TRUE}
plot_network(clustering_output = tg$EC1_CD4T)

# this does work if turbogliph output is saved in that folder
# but this would need a different folder for every tg-output, so kind of impracticable
#plot_network(result_folder = tg_results) 

#viz$EC1_CD4T # this only works in the markdown preview

# this does not work:
#viewer = getOption("viewer")
#viewer(viz$EC1_CD4T) 

```

### EC1 - CD8 T Network
```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC1_CD8T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```


```{r EC1_CD8_plot, include=TRUE}
plot_network(clustering_output = tg$EC1_CD8T)
```

### EC1 - CD4 T + CD8 T Network

Just for comparison/consistency check

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC1_CD48T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r EC1_CD48_plot, include=TRUE}
plot_network(clustering_output = tg$EC1_CD48T)
```

## Patient EC2+5

CD4 T-cells don't seem to be depleted in comparison to CD8 T-cells, which could contribute to the hypothesis of [NEC CD4 T-Cell Depleation]. Only patient with a count of CD4 T-cells being even higher than that of CD8 T-cells. Cell count seems to be a bit lower in comparison to [Patient EC1] if being split into the 2 measurements. 
<br>
A big amount of [Repertoire Overlap] was found for CD4T cells between EC2, EC5, and EC2+5. Only half of that amount of overlap was found between EC2, EC5, and EC2+5 for CD8T cells. **-\> maybe EC CD8T cells changing over time or something like that?**

```{r EC2_5_counts, echo=FALSE}
#aggregate(list(clone_count_2_5=dt$EC2_5_CD48T$counts), list(cell_type=dt$EC2_5_CD48T$l1ctype), sum)          
#aggregate(list(clone_count_2=dt$EC2_CD48T$counts), list(cell_type=dt$EC2_CD48T$l1ctype), sum)  
#aggregate(list(clone_count_5=dt$EC5_CD48T$counts), list(cell_type=dt$EC5_CD48T$l1ctype), sum)  

cat("Patient EC2+5")

ec2_5 = filter(clones_and_cellcounts, Patient == "EC2+5") 
ec2_5$Patient = NULL
print(ec2_5,row.names = FALSE)

cat("Patient EC2")

ec2 = filter(clones_and_cellcounts, Patient == "EC2") 
ec2$Patient = NULL
print(ec2,row.names = FALSE)

cat("Patient EC5")

ec5 = filter(clones_and_cellcounts, Patient == "EC5") 
ec5$Patient = NULL
print(ec5,row.names = FALSE)

rm(ec2,ec5,ec2_5)

```
Checking for [HIV Specificity] revealed four perfect matches for CD4T cells and one perfect match for CD8T cells. All supposed CD4T cells are marked as CD8T cells inside the matching CDR3b entries of VDJdb.

```{r EC2_5_specificity, echo=FALSE}

a = filter(dt$tcrs_transformed, patient == "EC2+5")
a = filter(a, dl_dist == 0)

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

rm(a)

```

Checking for [HIV Specificity] with Damerau-Levenshtein distance <= 1 revealed 92 matches for CD4T and CD8T cells.

```{r EC2_5_specificity_dl1, echo=FALSE}

#cat("Annotation Matches - Damerau-Levenshtein distance <= 1")

#subset_specificity_dl1('EC2_5_CD4T','EC2_5_CD8T')

a = filter(dt$tcrs_transformed, patient == "EC2+5")
a = filter(a, match_hiv == 1)

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

#plot(density(a$p_gen), main = "Random CDR3b Generation Probability")

rm(a)

```

Checking for [HIV Specificity] based on a BLAST e-value < 1e-04 (roughly based on all patients e-value for perfect matches) revealed 179 matches for CD4T and CD8T cells, as well as cells being marked as B, Mono, NK, other T and NA.

```{r EC2_5specificity_BLAST, echo=FALSE}

a = filter(dt$tcrs_transformed, patient == "EC2+5")
a = filter(a, BLAST_e < 1e-04)

a = a[order(a$l1ctype, a$BLAST_e),]

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

rm(a)

```

### EC2+5 - CD4 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC2_5_CD4T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r EC2+5_CD4_plot, include=TRUE}
plot_network(clustering_output = tg$EC2_5_CD4T)
```

#### EC2 - CD4 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC2_CD4T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r EC2_CD4_plot, include=TRUE}
plot_network(clustering_output = tg$EC2_CD4T)
```

#### EC5 - CD4 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC5_CD4T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r EC5_CD4_plot, include=TRUE}
plot_network(clustering_output = tg$EC5_CD4T)
```

### EC2+5 - CD8 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC2_5_CD8T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r EC2+5_CD8_plot, include=TRUE}
plot_network(clustering_output = tg$EC2_5_CD8T)
```

#### EC2 - CD8 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC2_CD8T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r EC2_CD8_plot, include=TRUE}
plot_network(clustering_output = tg$EC2_CD8T)
```

#### EC5 - CD8 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC5_CD8T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r EC5_CD8_plot, include=TRUE}
plot_network(clustering_output = tg$EC5_CD8T)
```


### EC2+5 - CD4 T + CD8 T Network

Just for comparison/consistency check

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC2_5_CD48T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r EC2+5_CD48_plot, include=TRUE}
plot_network(clustering_output = tg$EC2_5_CD48T)
```

#### EC2 - CD4 T + CD8 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC2_CD48T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r EC2_CD48_plot, include=TRUE}
plot_network(clustering_output = tg$EC2_CD48T)
```

#### EC5 - CD4 T + CD8 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC5_CD48T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r EC5_CD48_plot, include=TRUE}
plot_network(clustering_output = tg$EC5_CD48T)
```


## Patient EC4

Cell count of CD4 T-cells vs CD8 T-cells looks quite similar, so hypothesis [NEC CD4 T-Cell Depleation] is somehow confirmed. Cell count seems to be quite low in comparison, potentially causing inconsistent results in form of sparsely populated networks. This could also be the reason for higher TurboGliph simulation depths leading to the inability to calculate networks, as mentioned in [TCR Analysis].

```{r EC4_counts, echo=FALSE}
#aggregate(list(clone_count=dt$EC4_CD48T$counts), list(cell_type = dt$EC4_CD48T$l1ctype), sum)
ec4 = filter(clones_and_cellcounts, Patient == "EC4") 
ec4$Patient = NULL
print(ec4,row.names = FALSE)
rm(ec4)

```
Checking for [HIV Specificity] revealed one perfect match for CD4T cells. The supposed CD4T cell is marked as a CD8T cell inside the matching CDR3b entry of VDJdb.

```{r EC4_specificity, echo=FALSE}

a = filter(dt$tcrs_transformed, patient == "EC4")
a = filter(a, dl_dist == 0)

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

rm(a)


```

Checking for [HIV Specificity] with Damerau-Levenshtein distance <= 1 revealed 42 matches for CD4T and CD8T cells.

```{r EC4_specificity_dl1, echo=FALSE}

#cat("Annotation Matches - Damerau-Levenshtein distance <= 1")

#subset_specificity_dl1('EC4_CD4T','EC4_CD8T')

a = filter(dt$tcrs_transformed, patient == "EC4")
a = filter(a, match_hiv == 1)

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

#plot(density(a$p_gen), main = "Random CDR3b Generation Probability")

rm(a)


```

Checking for [HIV Specificity] based on a BLAST e-value < 1e-04 (roughly based on all patients e-value for perfect matches) revealed 75 matches for CD4T and CD8T cells, as well as a cell being marked as NA.

```{r EC4_specificity_BLAST, echo=FALSE}

a = filter(dt$tcrs_transformed, patient == "EC4")
a = filter(a, BLAST_e < 1e-04)
a = a[order(a$l1ctype, a$BLAST_e),]

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

rm(a)

```

### EC4 - CD4 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC4_CD4T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r EC4_CD4_plot, include=TRUE}
plot_network(clustering_output = tg$EC4_CD4T)
```

### EC4 - CD8 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC4_CD8T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r EC4_CD8_plot, include=TRUE}
plot_network(clustering_output = tg$EC4_CD8T)
```

### EC4 - CD4 T + CD8 T Network

Just for comparison/consistency check

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$EC4_CD48T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r EC4_CD48_plot, include=TRUE}
plot_network(clustering_output = tg$EC4_CD48T)
```


## Patient NEC1

CD4 T-cells seem to be depleted in comparison to CD8 T-cells, which could contribute to the hypothesis of [NEC CD4 T-Cell Depleation]. Cell count seems to be quite good in comparison, although relatively low.

```{r NEC1_counts, echo=FALSE}
#aggregate(list(clone_count=dt$NEC1_CD48T$counts), list(cell_type = dt$NEC1_CD48T$l1ctype), sum)
nec1 = filter(clones_and_cellcounts, Patient == "NEC1") 
nec1$Patient = NULL
print(nec1,row.names = FALSE)
rm(nec1)

```
Checking for [HIV Specificity] revealed three perfect matches for CD8T cells, one of them with a clone member count of two.

```{r NEC1_specificity, echo=FALSE}

a = filter(dt$tcrs_transformed, patient == "NEC1")
a = filter(a, dl_dist == 0)

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

rm(a)


```
Matching CDR3b (CASSETGGTYEQYF) and CDR3a (CVVNSGAGSYQLTF), also found in [Patient NEC4]

Checking for [HIV Specificity] with Damerau-Levenshtein distance <= 1 revealed 55 matches for CD4T and CD8T cells.

```{r NEC1_specificity_dl1, echo=FALSE}

#cat("Annotation Matches - Damerau-Levenshtein distance <= 1")

#subset_specificity_dl1('NEC1_CD4T','NEC1_CD8T')

a = filter(dt$tcrs_transformed, patient == "NEC1")
a = filter(a, match_hiv == 1)

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

#plot(density(a$p_gen), main = "Random CDR3b Generation Probability")

rm(a)

```

Checking for [HIV Specificity] based on a BLAST e-value < 1e-04 (roughly based on all patients e-value for perfect matches) revealed 122 matches for CD4T and CD8T cells, as well as cells being marked as B, Mono, NK, other T and NA.

```{r NEC1_specificity_BLAST, echo=FALSE}

a = filter(dt$tcrs_transformed, patient == "NEC1")
a = filter(a, BLAST_e < 1e-04)
a = a[order(a$l1ctype, a$BLAST_e),]

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

rm(a)

```

### NEC1 - CD4 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$NEC1_CD4T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r NEC1_CD4_plot, include=TRUE}
plot_network(clustering_output = tg$NEC1_CD4T)
```

### NEC1 - CD8 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$NEC1_CD8T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r NEC1_CD8_plot, include=TRUE}
plot_network(clustering_output = tg$NEC1_CD8T)
```

### NEC1 - CD4 T + CD8 T Network

Just for comparison/consistency check

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$NEC1_CD48T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r NEC1_CD48_plot, include=TRUE}
plot_network(clustering_output = tg$NEC1_CD48T)
```

## Patient NEC2

CD4 T-cells seem to be depleted in comparison to CD8 T-cells, which supports the hypothesis of [NEC CD4 T-Cell Depleation]. Looking at the cell count there seem to be fewer CD4 T cells.

```{r NEC2_counts, echo=FALSE}
#aggregate(list(clone_count=dt$NEC2_CD48T$counts), list(cell_type = dt$NEC2_CD48T$l1ctype), sum)
nec2 = filter(clones_and_cellcounts, Patient == "NEC2") 
nec2$Patient = NULL
print(nec2,row.names = FALSE)
rm(nec2)

```
Checking for [HIV Specificity] revealed no perfect matches for CD4T or CD8T cells.

```{r NEC2_specificity, echo=FALSE}

a = filter(dt$tcrs_transformed, patient == "NEC2")
a = filter(a, dl_dist == 0)

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

rm(a)

```

Checking for [HIV Specificity] with Damerau-Levenshtein distance <= 1 revealed 31 matches for CD4T and CD8T cells.

```{r NEC2_specificity_dl1, echo=FALSE}

#cat("Annotation Matches - Damerau-Levenshtein distance <= 1")

#subset_specificity_dl1('NEC2_CD4T','NEC2_CD8T')

a = filter(dt$tcrs_transformed, patient == "NEC2")
a = filter(a, match_hiv == 1)

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

#plot(density(a$p_gen), main = "Random CDR3b Generation Probability")

rm(a)

```

Checking for [HIV Specificity] based on a BLAST e-value < 1e-04 (roughly based on all patients e-value for perfect matches) revealed 85 matches for CD4T and CD8T cells, as well as cells being marked as B, Mono, NK and other T.

```{r NEC2_specificity_BLAST, echo=FALSE}

a = filter(dt$tcrs_transformed, patient == "NEC2")
a = filter(a, BLAST_e < 1e-04)
a = a[order(a$l1ctype, a$BLAST_e),]

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

rm(a)

```

### NEC2 - CD4 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$NEC2_CD4T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r NEC2_CD4_plot, include=TRUE}
plot_network(clustering_output = tg$NEC2_CD4T)
```

### NEC2 - CD8 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$NEC2_CD8T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r NEC2_CD8_plot, include=TRUE}
plot_network(clustering_output = tg$NEC2_CD8T)
```

### NEC2 - CD4 T + CD8 T Network

Just for comparison/consistency check

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$NEC2_CD48T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r NEC2_CD48_plot, include=TRUE}
plot_network(clustering_output = tg$NEC2_CD48T)
```

## Patient NEC4

CD4 T-cells seem to be depletion in comparison to CD8 T-cells, which supports the hypothesis of [NEC CD4 T-Cell Depleation]. Cell count seems to be ok in comparison, although relatively low. CD4 T-cells seem to be depleted most in all NEC patients.

```{r NEC4counts, echo=FALSE}
#aggregate(list(clone_count=dt$NEC4_CD48T$counts), list(cell_type = dt$NEC4_CD48T$l1ctype), sum)
nec4 = filter(clones_and_cellcounts, Patient == "NEC4") 
nec4$Patient = NULL
print(nec4,row.names = FALSE)

rm(nec4)#,clones_and_cellcounts)
```
Checking for [HIV Specificity] revealed three perfect matches for CD8T cells, one of them with a clone member count of 15.

```{r NEC4_specificity, echo=FALSE}
a = filter(dt$tcrs_transformed, patient == "NEC4")
a = filter(a, dl_dist == 0)

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

rm(a)


```
Matching CDR3b (CASSETGGTYEQYF) and CDR3a (CVVNSGAGSYQLTF), also found in [Patient NEC1]

Checking for [HIV Specificity] with Damerau-Levenshtein distance <= 1 revealed 45 matches for CD4T and CD8T cells.

```{r NEC4_specificity_dl1, echo=FALSE}

#cat("Annotation Matches - Damerau-Levenshtein distance <= 1")

#subset_specificity_dl1('NEC4_CD4T','NEC4_CD8T')

a = filter(dt$tcrs_transformed, patient == "NEC4")
a = filter(a, match_hiv == 1)

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

#plot(density(a$p_gen), main = "Random CDR3b Generation Probability")

rm(a)

```

Checking for [HIV Specificity] based on a BLAST e-value < 1e-04 (roughly based on all patients e-value for perfect matches) revealed 89 matches for CD4T and CD8T cells, as well as cells being marked as Mono and other T.

```{r NEC4_specificity_BLAST, echo=FALSE}

a = filter(dt$tcrs_transformed, patient == "NEC4")
a = filter(a, BLAST_e < 1.0e-04)
a = a[order(a$l1ctype, a$BLAST_e),]

kable(a[c("CDR3b", "patient", "condition", 
          "TRBV", "TRBJ", 
          "l1ctype", 
          "l1score", 
          "counts",
          "p_gen",
          "BLOSUM62_score",
          "BLOSUM62_pattern",
          "dl_dist",
          "BLAST_e",
          "BLAST_pattern")])

rm(a)

```

### NEC4 - CD4 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$NEC4_CD4T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r NEC4_CD4_plot, include=TRUE}
plot_network(clustering_output = tg$NEC4_CD4T)
```

### NEC4 - CD8 T Network

```{r,  echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$NEC4_CD8T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r NEC4_CD8_plot, include=TRUE}
plot_network(clustering_output = tg$NEC4_CD8T)
```

### NEC4 - CD4 T + CD8 T Network

Just for comparison/consistency check

```{r, echo=FALSE}
tmp = convert_visnet_to_igraph(tg_sample = tg$NEC4_CD48T, min_vertex_size = 3)

par(mar=c(0,0,0,0)+.1)
plot(tmp,
     edge.width = 2,
     edge.arrow.size = 0.1,
     vertex.label = V(tmp)$counts,
     vertex.label.cex = 0.8,
     vertex.size = V(tmp)$log2_counts,
     vertex.color = "white",
     edge.color = get.edge.attribute(
       graph = tmp, name = "color"))

rm(tmp)

```

```{r NEC4_CD48_plot, include=TRUE}
plot_network(clustering_output = tg$NEC4_CD48T)
```

```{r}
# final cleanup

rm(clones_and_cellcounts, specificity_mcpas, specificity_mcpas_dl1,
   specificity_tbadb, specificity_tbadb_dl1, specificity_vdjdb, specificity_vdjdb_dl1)

```


# Session Information

```{r}
sessionInfo()
```

